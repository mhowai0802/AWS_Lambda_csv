{"ast":null,"code":"/*\nCSV Parse\n\nPlease look at the [project documentation](https://csv.js.org/parse/) for\nadditional information.\n*/\nconst {\n  Transform\n} = require('stream');\n\nconst ResizeableBuffer = require('./ResizeableBuffer'); // white space characters\n// https://en.wikipedia.org/wiki/Whitespace_character\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions/Character_Classes#Types\n// \\f\\n\\r\\t\\v\\u00a0\\u1680\\u2000-\\u200a\\u2028\\u2029\\u202f\\u205f\\u3000\\ufeff\n\n\nconst tab = 9;\nconst nl = 10; // \\n, 0x0A in hexadecimal, 10 in decimal\n\nconst np = 12;\nconst cr = 13; // \\r, 0x0D in hexadÃ©cimal, 13 in decimal\n\nconst space = 32;\nconst boms = {\n  // Note, the following are equals:\n  // Buffer.from(\"\\ufeff\")\n  // Buffer.from([239, 187, 191])\n  // Buffer.from('EFBBBF', 'hex')\n  'utf8': Buffer.from([239, 187, 191]),\n  // Note, the following are equals:\n  // Buffer.from \"\\ufeff\", 'utf16le\n  // Buffer.from([255, 254])\n  'utf16le': Buffer.from([255, 254])\n};\n\nclass Parser extends Transform {\n  constructor() {\n    let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    super({ ...{\n        readableObjectMode: true\n      },\n      ...opts,\n      encoding: null\n    });\n    this.__originalOptions = opts;\n\n    this.__normalizeOptions(opts);\n  }\n\n  __normalizeOptions(opts) {\n    const options = {}; // Merge with user options\n\n    for (let opt in opts) {\n      options[underscore(opt)] = opts[opt];\n    } // Normalize option `encoding`\n    // Note: defined first because other options depends on it\n    // to convert chars/strings into buffers.\n\n\n    if (options.encoding === undefined || options.encoding === true) {\n      options.encoding = 'utf8';\n    } else if (options.encoding === null || options.encoding === false) {\n      options.encoding = null;\n    } else if (typeof options.encoding !== 'string' && options.encoding !== null) {\n      throw new CsvError('CSV_INVALID_OPTION_ENCODING', ['Invalid option encoding:', 'encoding must be a string or null to return a buffer,', `got ${JSON.stringify(options.encoding)}`], options);\n    } // Normalize option `bom`\n\n\n    if (options.bom === undefined || options.bom === null || options.bom === false) {\n      options.bom = false;\n    } else if (options.bom !== true) {\n      throw new CsvError('CSV_INVALID_OPTION_BOM', ['Invalid option bom:', 'bom must be true,', `got ${JSON.stringify(options.bom)}`], options);\n    } // Normalize option `cast`\n\n\n    let fnCastField = null;\n\n    if (options.cast === undefined || options.cast === null || options.cast === false || options.cast === '') {\n      options.cast = undefined;\n    } else if (typeof options.cast === 'function') {\n      fnCastField = options.cast;\n      options.cast = true;\n    } else if (options.cast !== true) {\n      throw new CsvError('CSV_INVALID_OPTION_CAST', ['Invalid option cast:', 'cast must be true or a function,', `got ${JSON.stringify(options.cast)}`], options);\n    } // Normalize option `cast_date`\n\n\n    if (options.cast_date === undefined || options.cast_date === null || options.cast_date === false || options.cast_date === '') {\n      options.cast_date = false;\n    } else if (options.cast_date === true) {\n      options.cast_date = function (value) {\n        const date = Date.parse(value);\n        return !isNaN(date) ? new Date(date) : value;\n      };\n    } else {\n      throw new CsvError('CSV_INVALID_OPTION_CAST_DATE', ['Invalid option cast_date:', 'cast_date must be true or a function,', `got ${JSON.stringify(options.cast_date)}`], options);\n    } // Normalize option `columns`\n\n\n    let fnFirstLineToHeaders = null;\n\n    if (options.columns === true) {\n      // Fields in the first line are converted as-is to columns\n      fnFirstLineToHeaders = undefined;\n    } else if (typeof options.columns === 'function') {\n      fnFirstLineToHeaders = options.columns;\n      options.columns = true;\n    } else if (Array.isArray(options.columns)) {\n      options.columns = normalizeColumnsArray(options.columns);\n    } else if (options.columns === undefined || options.columns === null || options.columns === false) {\n      options.columns = false;\n    } else {\n      throw new CsvError('CSV_INVALID_OPTION_COLUMNS', ['Invalid option columns:', 'expect an array, a function or true,', `got ${JSON.stringify(options.columns)}`], options);\n    } // Normalize option `columns_duplicates_to_array`\n\n\n    if (options.columns_duplicates_to_array === undefined || options.columns_duplicates_to_array === null || options.columns_duplicates_to_array === false) {\n      options.columns_duplicates_to_array = false;\n    } else if (options.columns_duplicates_to_array !== true) {\n      throw new CsvError('CSV_INVALID_OPTION_COLUMNS_DUPLICATES_TO_ARRAY', ['Invalid option columns_duplicates_to_array:', 'expect an boolean,', `got ${JSON.stringify(options.columns_duplicates_to_array)}`], options);\n    } else if (options.columns === false) {\n      throw new CsvError('CSV_INVALID_OPTION_COLUMNS_DUPLICATES_TO_ARRAY', ['Invalid option columns_duplicates_to_array:', 'the `columns` mode must be activated.'], options);\n    } // Normalize option `comment`\n\n\n    if (options.comment === undefined || options.comment === null || options.comment === false || options.comment === '') {\n      options.comment = null;\n    } else {\n      if (typeof options.comment === 'string') {\n        options.comment = Buffer.from(options.comment, options.encoding);\n      }\n\n      if (!Buffer.isBuffer(options.comment)) {\n        throw new CsvError('CSV_INVALID_OPTION_COMMENT', ['Invalid option comment:', 'comment must be a buffer or a string,', `got ${JSON.stringify(options.comment)}`], options);\n      }\n    } // Normalize option `delimiter`\n\n\n    const delimiter_json = JSON.stringify(options.delimiter);\n    if (!Array.isArray(options.delimiter)) options.delimiter = [options.delimiter];\n\n    if (options.delimiter.length === 0) {\n      throw new CsvError('CSV_INVALID_OPTION_DELIMITER', ['Invalid option delimiter:', 'delimiter must be a non empty string or buffer or array of string|buffer,', `got ${delimiter_json}`], options);\n    }\n\n    options.delimiter = options.delimiter.map(function (delimiter) {\n      if (delimiter === undefined || delimiter === null || delimiter === false) {\n        return Buffer.from(',', options.encoding);\n      }\n\n      if (typeof delimiter === 'string') {\n        delimiter = Buffer.from(delimiter, options.encoding);\n      }\n\n      if (!Buffer.isBuffer(delimiter) || delimiter.length === 0) {\n        throw new CsvError('CSV_INVALID_OPTION_DELIMITER', ['Invalid option delimiter:', 'delimiter must be a non empty string or buffer or array of string|buffer,', `got ${delimiter_json}`], options);\n      }\n\n      return delimiter;\n    }); // Normalize option `escape`\n\n    if (options.escape === undefined || options.escape === true) {\n      options.escape = Buffer.from('\"', options.encoding);\n    } else if (typeof options.escape === 'string') {\n      options.escape = Buffer.from(options.escape, options.encoding);\n    } else if (options.escape === null || options.escape === false) {\n      options.escape = null;\n    }\n\n    if (options.escape !== null) {\n      if (!Buffer.isBuffer(options.escape)) {\n        throw new Error(`Invalid Option: escape must be a buffer, a string or a boolean, got ${JSON.stringify(options.escape)}`);\n      }\n    } // Normalize option `from`\n\n\n    if (options.from === undefined || options.from === null) {\n      options.from = 1;\n    } else {\n      if (typeof options.from === 'string' && /\\d+/.test(options.from)) {\n        options.from = parseInt(options.from);\n      }\n\n      if (Number.isInteger(options.from)) {\n        if (options.from < 0) {\n          throw new Error(`Invalid Option: from must be a positive integer, got ${JSON.stringify(opts.from)}`);\n        }\n      } else {\n        throw new Error(`Invalid Option: from must be an integer, got ${JSON.stringify(options.from)}`);\n      }\n    } // Normalize option `from_line`\n\n\n    if (options.from_line === undefined || options.from_line === null) {\n      options.from_line = 1;\n    } else {\n      if (typeof options.from_line === 'string' && /\\d+/.test(options.from_line)) {\n        options.from_line = parseInt(options.from_line);\n      }\n\n      if (Number.isInteger(options.from_line)) {\n        if (options.from_line <= 0) {\n          throw new Error(`Invalid Option: from_line must be a positive integer greater than 0, got ${JSON.stringify(opts.from_line)}`);\n        }\n      } else {\n        throw new Error(`Invalid Option: from_line must be an integer, got ${JSON.stringify(opts.from_line)}`);\n      }\n    } // Normalize options `ignore_last_delimiters`\n\n\n    if (options.ignore_last_delimiters === undefined || options.ignore_last_delimiters === null) {\n      options.ignore_last_delimiters = false;\n    } else if (typeof options.ignore_last_delimiters === 'number') {\n      options.ignore_last_delimiters = Math.floor(options.ignore_last_delimiters);\n\n      if (options.ignore_last_delimiters === 0) {\n        options.ignore_last_delimiters = false;\n      }\n    } else if (typeof options.ignore_last_delimiters !== 'boolean') {\n      throw new CsvError('CSV_INVALID_OPTION_IGNORE_LAST_DELIMITERS', ['Invalid option `ignore_last_delimiters`:', 'the value must be a boolean value or an integer,', `got ${JSON.stringify(options.ignore_last_delimiters)}`], options);\n    }\n\n    if (options.ignore_last_delimiters === true && options.columns === false) {\n      throw new CsvError('CSV_IGNORE_LAST_DELIMITERS_REQUIRES_COLUMNS', ['The option `ignore_last_delimiters`', 'requires the activation of the `columns` option'], options);\n    } // Normalize option `info`\n\n\n    if (options.info === undefined || options.info === null || options.info === false) {\n      options.info = false;\n    } else if (options.info !== true) {\n      throw new Error(`Invalid Option: info must be true, got ${JSON.stringify(options.info)}`);\n    } // Normalize option `max_record_size`\n\n\n    if (options.max_record_size === undefined || options.max_record_size === null || options.max_record_size === false) {\n      options.max_record_size = 0;\n    } else if (Number.isInteger(options.max_record_size) && options.max_record_size >= 0) {// Great, nothing to do\n    } else if (typeof options.max_record_size === 'string' && /\\d+/.test(options.max_record_size)) {\n      options.max_record_size = parseInt(options.max_record_size);\n    } else {\n      throw new Error(`Invalid Option: max_record_size must be a positive integer, got ${JSON.stringify(options.max_record_size)}`);\n    } // Normalize option `objname`\n\n\n    if (options.objname === undefined || options.objname === null || options.objname === false) {\n      options.objname = undefined;\n    } else if (Buffer.isBuffer(options.objname)) {\n      if (options.objname.length === 0) {\n        throw new Error(`Invalid Option: objname must be a non empty buffer`);\n      }\n\n      if (options.encoding === null) {// Don't call `toString`, leave objname as a buffer\n      } else {\n        options.objname = options.objname.toString(options.encoding);\n      }\n    } else if (typeof options.objname === 'string') {\n      if (options.objname.length === 0) {\n        throw new Error(`Invalid Option: objname must be a non empty string`);\n      } // Great, nothing to do\n\n    } else {\n      throw new Error(`Invalid Option: objname must be a string or a buffer, got ${options.objname}`);\n    } // Normalize option `on_record`\n\n\n    if (options.on_record === undefined || options.on_record === null) {\n      options.on_record = undefined;\n    } else if (typeof options.on_record !== 'function') {\n      throw new CsvError('CSV_INVALID_OPTION_ON_RECORD', ['Invalid option `on_record`:', 'expect a function,', `got ${JSON.stringify(options.on_record)}`], options);\n    } // Normalize option `quote`\n\n\n    if (options.quote === null || options.quote === false || options.quote === '') {\n      options.quote = null;\n    } else {\n      if (options.quote === undefined || options.quote === true) {\n        options.quote = Buffer.from('\"', options.encoding);\n      } else if (typeof options.quote === 'string') {\n        options.quote = Buffer.from(options.quote, options.encoding);\n      }\n\n      if (!Buffer.isBuffer(options.quote)) {\n        throw new Error(`Invalid Option: quote must be a buffer or a string, got ${JSON.stringify(options.quote)}`);\n      }\n    } // Normalize option `raw`\n\n\n    if (options.raw === undefined || options.raw === null || options.raw === false) {\n      options.raw = false;\n    } else if (options.raw !== true) {\n      throw new Error(`Invalid Option: raw must be true, got ${JSON.stringify(options.raw)}`);\n    } // Normalize option `record_delimiter`\n\n\n    if (!options.record_delimiter) {\n      options.record_delimiter = [];\n    } else if (!Array.isArray(options.record_delimiter)) {\n      options.record_delimiter = [options.record_delimiter];\n    }\n\n    options.record_delimiter = options.record_delimiter.map(function (rd) {\n      if (typeof rd === 'string') {\n        rd = Buffer.from(rd, options.encoding);\n      }\n\n      return rd;\n    }); // Normalize option `relax`\n\n    if (typeof options.relax === 'boolean') {// Great, nothing to do\n    } else if (options.relax === undefined || options.relax === null) {\n      options.relax = false;\n    } else {\n      throw new Error(`Invalid Option: relax must be a boolean, got ${JSON.stringify(options.relax)}`);\n    } // Normalize option `relax_column_count`\n\n\n    if (typeof options.relax_column_count === 'boolean') {// Great, nothing to do\n    } else if (options.relax_column_count === undefined || options.relax_column_count === null) {\n      options.relax_column_count = false;\n    } else {\n      throw new Error(`Invalid Option: relax_column_count must be a boolean, got ${JSON.stringify(options.relax_column_count)}`);\n    }\n\n    if (typeof options.relax_column_count_less === 'boolean') {// Great, nothing to do\n    } else if (options.relax_column_count_less === undefined || options.relax_column_count_less === null) {\n      options.relax_column_count_less = false;\n    } else {\n      throw new Error(`Invalid Option: relax_column_count_less must be a boolean, got ${JSON.stringify(options.relax_column_count_less)}`);\n    }\n\n    if (typeof options.relax_column_count_more === 'boolean') {// Great, nothing to do\n    } else if (options.relax_column_count_more === undefined || options.relax_column_count_more === null) {\n      options.relax_column_count_more = false;\n    } else {\n      throw new Error(`Invalid Option: relax_column_count_more must be a boolean, got ${JSON.stringify(options.relax_column_count_more)}`);\n    } // Normalize option `skip_empty_lines`\n\n\n    if (typeof options.skip_empty_lines === 'boolean') {// Great, nothing to do\n    } else if (options.skip_empty_lines === undefined || options.skip_empty_lines === null) {\n      options.skip_empty_lines = false;\n    } else {\n      throw new Error(`Invalid Option: skip_empty_lines must be a boolean, got ${JSON.stringify(options.skip_empty_lines)}`);\n    } // Normalize option `skip_lines_with_empty_values`\n\n\n    if (typeof options.skip_lines_with_empty_values === 'boolean') {// Great, nothing to do\n    } else if (options.skip_lines_with_empty_values === undefined || options.skip_lines_with_empty_values === null) {\n      options.skip_lines_with_empty_values = false;\n    } else {\n      throw new Error(`Invalid Option: skip_lines_with_empty_values must be a boolean, got ${JSON.stringify(options.skip_lines_with_empty_values)}`);\n    } // Normalize option `skip_lines_with_error`\n\n\n    if (typeof options.skip_lines_with_error === 'boolean') {// Great, nothing to do\n    } else if (options.skip_lines_with_error === undefined || options.skip_lines_with_error === null) {\n      options.skip_lines_with_error = false;\n    } else {\n      throw new Error(`Invalid Option: skip_lines_with_error must be a boolean, got ${JSON.stringify(options.skip_lines_with_error)}`);\n    } // Normalize option `rtrim`\n\n\n    if (options.rtrim === undefined || options.rtrim === null || options.rtrim === false) {\n      options.rtrim = false;\n    } else if (options.rtrim !== true) {\n      throw new Error(`Invalid Option: rtrim must be a boolean, got ${JSON.stringify(options.rtrim)}`);\n    } // Normalize option `ltrim`\n\n\n    if (options.ltrim === undefined || options.ltrim === null || options.ltrim === false) {\n      options.ltrim = false;\n    } else if (options.ltrim !== true) {\n      throw new Error(`Invalid Option: ltrim must be a boolean, got ${JSON.stringify(options.ltrim)}`);\n    } // Normalize option `trim`\n\n\n    if (options.trim === undefined || options.trim === null || options.trim === false) {\n      options.trim = false;\n    } else if (options.trim !== true) {\n      throw new Error(`Invalid Option: trim must be a boolean, got ${JSON.stringify(options.trim)}`);\n    } // Normalize options `trim`, `ltrim` and `rtrim`\n\n\n    if (options.trim === true && opts.ltrim !== false) {\n      options.ltrim = true;\n    } else if (options.ltrim !== true) {\n      options.ltrim = false;\n    }\n\n    if (options.trim === true && opts.rtrim !== false) {\n      options.rtrim = true;\n    } else if (options.rtrim !== true) {\n      options.rtrim = false;\n    } // Normalize option `to`\n\n\n    if (options.to === undefined || options.to === null) {\n      options.to = -1;\n    } else {\n      if (typeof options.to === 'string' && /\\d+/.test(options.to)) {\n        options.to = parseInt(options.to);\n      }\n\n      if (Number.isInteger(options.to)) {\n        if (options.to <= 0) {\n          throw new Error(`Invalid Option: to must be a positive integer greater than 0, got ${JSON.stringify(opts.to)}`);\n        }\n      } else {\n        throw new Error(`Invalid Option: to must be an integer, got ${JSON.stringify(opts.to)}`);\n      }\n    } // Normalize option `to_line`\n\n\n    if (options.to_line === undefined || options.to_line === null) {\n      options.to_line = -1;\n    } else {\n      if (typeof options.to_line === 'string' && /\\d+/.test(options.to_line)) {\n        options.to_line = parseInt(options.to_line);\n      }\n\n      if (Number.isInteger(options.to_line)) {\n        if (options.to_line <= 0) {\n          throw new Error(`Invalid Option: to_line must be a positive integer greater than 0, got ${JSON.stringify(opts.to_line)}`);\n        }\n      } else {\n        throw new Error(`Invalid Option: to_line must be an integer, got ${JSON.stringify(opts.to_line)}`);\n      }\n    }\n\n    this.info = {\n      bytes: 0,\n      comment_lines: 0,\n      empty_lines: 0,\n      invalid_field_length: 0,\n      lines: 1,\n      records: 0\n    };\n    this.options = options;\n    this.state = {\n      bomSkipped: false,\n      bufBytesStart: 0,\n      castField: fnCastField,\n      commenting: false,\n      // Current error encountered by a record\n      error: undefined,\n      enabled: options.from_line === 1,\n      escaping: false,\n      // escapeIsQuote: options.escape === options.quote,\n      escapeIsQuote: Buffer.isBuffer(options.escape) && Buffer.isBuffer(options.quote) && Buffer.compare(options.escape, options.quote) === 0,\n      // columns can be `false`, `true`, `Array`\n      expectedRecordLength: Array.isArray(options.columns) ? options.columns.length : undefined,\n      field: new ResizeableBuffer(20),\n      firstLineToHeaders: fnFirstLineToHeaders,\n      needMoreDataSize: Math.max( // Skip if the remaining buffer smaller than comment\n      options.comment !== null ? options.comment.length : 0, // Skip if the remaining buffer can be delimiter\n      ...options.delimiter.map(delimiter => delimiter.length), // Skip if the remaining buffer can be escape sequence\n      options.quote !== null ? options.quote.length : 0),\n      previousBuf: undefined,\n      quoting: false,\n      stop: false,\n      rawBuffer: new ResizeableBuffer(100),\n      record: [],\n      recordHasError: false,\n      record_length: 0,\n      recordDelimiterMaxLength: options.record_delimiter.length === 0 ? 2 : Math.max(...options.record_delimiter.map(v => v.length)),\n      trimChars: [Buffer.from(' ', options.encoding)[0], Buffer.from('\\t', options.encoding)[0]],\n      wasQuoting: false,\n      wasRowDelimiter: false\n    };\n  } // Implementation of `Transform._transform`\n\n\n  _transform(buf, encoding, callback) {\n    if (this.state.stop === true) {\n      return;\n    }\n\n    const err = this.__parse(buf, false);\n\n    if (err !== undefined) {\n      this.state.stop = true;\n    }\n\n    callback(err);\n  } // Implementation of `Transform._flush`\n\n\n  _flush(callback) {\n    if (this.state.stop === true) {\n      return;\n    }\n\n    const err = this.__parse(undefined, true);\n\n    callback(err);\n  } // Central parser implementation\n\n\n  __parse(nextBuf, end) {\n    const {\n      bom,\n      comment,\n      escape,\n      from_line,\n      ltrim,\n      max_record_size,\n      quote,\n      raw,\n      relax,\n      rtrim,\n      skip_empty_lines,\n      to,\n      to_line\n    } = this.options;\n    let {\n      record_delimiter\n    } = this.options;\n    const {\n      bomSkipped,\n      previousBuf,\n      rawBuffer,\n      escapeIsQuote\n    } = this.state;\n    let buf;\n\n    if (previousBuf === undefined) {\n      if (nextBuf === undefined) {\n        // Handle empty string\n        this.push(null);\n        return;\n      } else {\n        buf = nextBuf;\n      }\n    } else if (previousBuf !== undefined && nextBuf === undefined) {\n      buf = previousBuf;\n    } else {\n      buf = Buffer.concat([previousBuf, nextBuf]);\n    } // Handle UTF BOM\n\n\n    if (bomSkipped === false) {\n      if (bom === false) {\n        this.state.bomSkipped = true;\n      } else if (buf.length < 3) {\n        // No enough data\n        if (end === false) {\n          // Wait for more data\n          this.state.previousBuf = buf;\n          return;\n        }\n      } else {\n        for (let encoding in boms) {\n          if (boms[encoding].compare(buf, 0, boms[encoding].length) === 0) {\n            // Skip BOM\n            let bomLength = boms[encoding].length;\n            this.state.bufBytesStart += bomLength;\n            buf = buf.slice(bomLength); // Renormalize original options with the new encoding\n\n            this.__normalizeOptions({ ...this.__originalOptions,\n              encoding: encoding\n            });\n\n            break;\n          }\n        }\n\n        this.state.bomSkipped = true;\n      }\n    }\n\n    const bufLen = buf.length;\n    let pos;\n\n    for (pos = 0; pos < bufLen; pos++) {\n      // Ensure we get enough space to look ahead\n      // There should be a way to move this out of the loop\n      if (this.__needMoreData(pos, bufLen, end)) {\n        break;\n      }\n\n      if (this.state.wasRowDelimiter === true) {\n        this.info.lines++;\n        this.state.wasRowDelimiter = false;\n      }\n\n      if (to_line !== -1 && this.info.lines > to_line) {\n        this.state.stop = true;\n        this.push(null);\n        return;\n      } // Auto discovery of record_delimiter, unix, mac and windows supported\n\n\n      if (this.state.quoting === false && record_delimiter.length === 0) {\n        const record_delimiterCount = this.__autoDiscoverRecordDelimiter(buf, pos);\n\n        if (record_delimiterCount) {\n          record_delimiter = this.options.record_delimiter;\n        }\n      }\n\n      const chr = buf[pos];\n\n      if (raw === true) {\n        rawBuffer.append(chr);\n      }\n\n      if ((chr === cr || chr === nl) && this.state.wasRowDelimiter === false) {\n        this.state.wasRowDelimiter = true;\n      } // Previous char was a valid escape char\n      // treat the current char as a regular char\n\n\n      if (this.state.escaping === true) {\n        this.state.escaping = false;\n      } else {\n        // Escape is only active inside quoted fields\n        // We are quoting, the char is an escape chr and there is a chr to escape\n        // if(escape !== null && this.state.quoting === true && chr === escape && pos + 1 < bufLen){\n        if (escape !== null && this.state.quoting === true && this.__isEscape(buf, pos, chr) && pos + escape.length < bufLen) {\n          if (escapeIsQuote) {\n            if (this.__isQuote(buf, pos + escape.length)) {\n              this.state.escaping = true;\n              pos += escape.length - 1;\n              continue;\n            }\n          } else {\n            this.state.escaping = true;\n            pos += escape.length - 1;\n            continue;\n          }\n        } // Not currently escaping and chr is a quote\n        // TODO: need to compare bytes instead of single char\n\n\n        if (this.state.commenting === false && this.__isQuote(buf, pos)) {\n          if (this.state.quoting === true) {\n            const nextChr = buf[pos + quote.length];\n\n            const isNextChrTrimable = rtrim && this.__isCharTrimable(nextChr);\n\n            const isNextChrComment = comment !== null && this.__compareBytes(comment, buf, pos + quote.length, nextChr);\n\n            const isNextChrDelimiter = this.__isDelimiter(buf, pos + quote.length, nextChr);\n\n            const isNextChrRecordDelimiter = record_delimiter.length === 0 ? this.__autoDiscoverRecordDelimiter(buf, pos + quote.length) : this.__isRecordDelimiter(nextChr, buf, pos + quote.length); // Escape a quote\n            // Treat next char as a regular character\n\n            if (escape !== null && this.__isEscape(buf, pos, chr) && this.__isQuote(buf, pos + escape.length)) {\n              pos += escape.length - 1;\n            } else if (!nextChr || isNextChrDelimiter || isNextChrRecordDelimiter || isNextChrComment || isNextChrTrimable) {\n              this.state.quoting = false;\n              this.state.wasQuoting = true;\n              pos += quote.length - 1;\n              continue;\n            } else if (relax === false) {\n              const err = this.__error(new CsvError('CSV_INVALID_CLOSING_QUOTE', ['Invalid Closing Quote:', `got \"${String.fromCharCode(nextChr)}\"`, `at line ${this.info.lines}`, 'instead of delimiter, record delimiter, trimable character', '(if activated) or comment'], this.options, this.__infoField()));\n\n              if (err !== undefined) return err;\n            } else {\n              this.state.quoting = false;\n              this.state.wasQuoting = true;\n              this.state.field.prepend(quote);\n              pos += quote.length - 1;\n            }\n          } else {\n            if (this.state.field.length !== 0) {\n              // In relax mode, treat opening quote preceded by chrs as regular\n              if (relax === false) {\n                const err = this.__error(new CsvError('INVALID_OPENING_QUOTE', ['Invalid Opening Quote:', `a quote is found inside a field at line ${this.info.lines}`], this.options, this.__infoField(), {\n                  field: this.state.field\n                }));\n\n                if (err !== undefined) return err;\n              }\n            } else {\n              this.state.quoting = true;\n              pos += quote.length - 1;\n              continue;\n            }\n          }\n        }\n\n        if (this.state.quoting === false) {\n          let recordDelimiterLength = this.__isRecordDelimiter(chr, buf, pos);\n\n          if (recordDelimiterLength !== 0) {\n            // Do not emit comments which take a full line\n            const skipCommentLine = this.state.commenting && this.state.wasQuoting === false && this.state.record.length === 0 && this.state.field.length === 0;\n\n            if (skipCommentLine) {\n              this.info.comment_lines++; // Skip full comment line\n            } else {\n              // Activate records emition if above from_line\n              if (this.state.enabled === false && this.info.lines + (this.state.wasRowDelimiter === true ? 1 : 0) >= from_line) {\n                this.state.enabled = true;\n\n                this.__resetField();\n\n                this.__resetRecord();\n\n                pos += recordDelimiterLength - 1;\n                continue;\n              } // Skip if line is empty and skip_empty_lines activated\n\n\n              if (skip_empty_lines === true && this.state.wasQuoting === false && this.state.record.length === 0 && this.state.field.length === 0) {\n                this.info.empty_lines++;\n                pos += recordDelimiterLength - 1;\n                continue;\n              }\n\n              this.info.bytes = this.state.bufBytesStart + pos;\n\n              const errField = this.__onField();\n\n              if (errField !== undefined) return errField;\n              this.info.bytes = this.state.bufBytesStart + pos + recordDelimiterLength;\n\n              const errRecord = this.__onRecord();\n\n              if (errRecord !== undefined) return errRecord;\n\n              if (to !== -1 && this.info.records >= to) {\n                this.state.stop = true;\n                this.push(null);\n                return;\n              }\n            }\n\n            this.state.commenting = false;\n            pos += recordDelimiterLength - 1;\n            continue;\n          }\n\n          if (this.state.commenting) {\n            continue;\n          }\n\n          const commentCount = comment === null ? 0 : this.__compareBytes(comment, buf, pos, chr);\n\n          if (commentCount !== 0) {\n            this.state.commenting = true;\n            continue;\n          }\n\n          let delimiterLength = this.__isDelimiter(buf, pos, chr);\n\n          if (delimiterLength !== 0) {\n            this.info.bytes = this.state.bufBytesStart + pos;\n\n            const errField = this.__onField();\n\n            if (errField !== undefined) return errField;\n            pos += delimiterLength - 1;\n            continue;\n          }\n        }\n      }\n\n      if (this.state.commenting === false) {\n        if (max_record_size !== 0 && this.state.record_length + this.state.field.length > max_record_size) {\n          const err = this.__error(new CsvError('CSV_MAX_RECORD_SIZE', ['Max Record Size:', 'record exceed the maximum number of tolerated bytes', `of ${max_record_size}`, `at line ${this.info.lines}`], this.options, this.__infoField()));\n\n          if (err !== undefined) return err;\n        }\n      }\n\n      const lappend = ltrim === false || this.state.quoting === true || this.state.field.length !== 0 || !this.__isCharTrimable(chr); // rtrim in non quoting is handle in __onField\n\n      const rappend = rtrim === false || this.state.wasQuoting === false;\n\n      if (lappend === true && rappend === true) {\n        this.state.field.append(chr);\n      } else if (rtrim === true && !this.__isCharTrimable(chr)) {\n        const err = this.__error(new CsvError('CSV_NON_TRIMABLE_CHAR_AFTER_CLOSING_QUOTE', ['Invalid Closing Quote:', 'found non trimable byte after quote', `at line ${this.info.lines}`], this.options, this.__infoField()));\n\n        if (err !== undefined) return err;\n      }\n    }\n\n    if (end === true) {\n      // Ensure we are not ending in a quoting state\n      if (this.state.quoting === true) {\n        const err = this.__error(new CsvError('CSV_QUOTE_NOT_CLOSED', ['Quote Not Closed:', `the parsing is finished with an opening quote at line ${this.info.lines}`], this.options, this.__infoField()));\n\n        if (err !== undefined) return err;\n      } else {\n        // Skip last line if it has no characters\n        if (this.state.wasQuoting === true || this.state.record.length !== 0 || this.state.field.length !== 0) {\n          this.info.bytes = this.state.bufBytesStart + pos;\n\n          const errField = this.__onField();\n\n          if (errField !== undefined) return errField;\n\n          const errRecord = this.__onRecord();\n\n          if (errRecord !== undefined) return errRecord;\n        } else if (this.state.wasRowDelimiter === true) {\n          this.info.empty_lines++;\n        } else if (this.state.commenting === true) {\n          this.info.comment_lines++;\n        }\n      }\n    } else {\n      this.state.bufBytesStart += pos;\n      this.state.previousBuf = buf.slice(pos);\n    }\n\n    if (this.state.wasRowDelimiter === true) {\n      this.info.lines++;\n      this.state.wasRowDelimiter = false;\n    }\n  }\n\n  __onRecord() {\n    const {\n      columns,\n      columns_duplicates_to_array,\n      encoding,\n      info,\n      from,\n      relax_column_count,\n      relax_column_count_less,\n      relax_column_count_more,\n      raw,\n      skip_lines_with_empty_values\n    } = this.options;\n    const {\n      enabled,\n      record\n    } = this.state;\n\n    if (enabled === false) {\n      return this.__resetRecord();\n    } // Convert the first line into column names\n\n\n    const recordLength = record.length;\n\n    if (columns === true) {\n      if (skip_lines_with_empty_values === true && isRecordEmpty(record)) {\n        this.__resetRecord();\n\n        return;\n      }\n\n      return this.__firstLineToColumns(record);\n    }\n\n    if (columns === false && this.info.records === 0) {\n      this.state.expectedRecordLength = recordLength;\n    }\n\n    if (recordLength !== this.state.expectedRecordLength) {\n      const err = columns === false ? // Todo: rename CSV_INCONSISTENT_RECORD_LENGTH to\n      // CSV_RECORD_INCONSISTENT_FIELDS_LENGTH\n      new CsvError('CSV_INCONSISTENT_RECORD_LENGTH', ['Invalid Record Length:', `expect ${this.state.expectedRecordLength},`, `got ${recordLength} on line ${this.info.lines}`], this.options, this.__infoField(), {\n        record: record\n      }) : // Todo: rename CSV_RECORD_DONT_MATCH_COLUMNS_LENGTH to\n      // CSV_RECORD_INCONSISTENT_COLUMNS\n      new CsvError('CSV_RECORD_DONT_MATCH_COLUMNS_LENGTH', ['Invalid Record Length:', `columns length is ${columns.length},`, // rename columns\n      `got ${recordLength} on line ${this.info.lines}`], this.options, this.__infoField(), {\n        record: record\n      });\n\n      if (relax_column_count === true || relax_column_count_less === true && recordLength < this.state.expectedRecordLength || relax_column_count_more === true && recordLength > this.state.expectedRecordLength) {\n        this.info.invalid_field_length++;\n        this.state.error = err; // Error is undefined with skip_lines_with_error\n      } else {\n        const finalErr = this.__error(err);\n\n        if (finalErr) return finalErr;\n      }\n    }\n\n    if (skip_lines_with_empty_values === true && isRecordEmpty(record)) {\n      this.__resetRecord();\n\n      return;\n    }\n\n    if (this.state.recordHasError === true) {\n      this.__resetRecord();\n\n      this.state.recordHasError = false;\n      return;\n    }\n\n    this.info.records++;\n\n    if (from === 1 || this.info.records >= from) {\n      // With columns, records are object\n      if (columns !== false) {\n        const obj = {}; // Transform record array to an object\n\n        for (let i = 0, l = record.length; i < l; i++) {\n          if (columns[i] === undefined || columns[i].disabled) continue; // Turn duplicate columns into an array\n\n          if (columns_duplicates_to_array === true && obj[columns[i].name] !== undefined) {\n            if (Array.isArray(obj[columns[i].name])) {\n              obj[columns[i].name] = obj[columns[i].name].concat(record[i]);\n            } else {\n              obj[columns[i].name] = [obj[columns[i].name], record[i]];\n            }\n          } else {\n            obj[columns[i].name] = record[i];\n          }\n        }\n\n        const {\n          objname\n        } = this.options; // Without objname (default)\n\n        if (objname === undefined) {\n          if (raw === true || info === true) {\n            const err = this.__push(Object.assign({\n              record: obj\n            }, raw === true ? {\n              raw: this.state.rawBuffer.toString(encoding)\n            } : {}, info === true ? {\n              info: this.__infoRecord()\n            } : {}));\n\n            if (err) {\n              return err;\n            }\n          } else {\n            const err = this.__push(obj);\n\n            if (err) {\n              return err;\n            }\n          } // With objname (default)\n\n        } else {\n          if (raw === true || info === true) {\n            const err = this.__push(Object.assign({\n              record: [obj[objname], obj]\n            }, raw === true ? {\n              raw: this.state.rawBuffer.toString(encoding)\n            } : {}, info === true ? {\n              info: this.__infoRecord()\n            } : {}));\n\n            if (err) {\n              return err;\n            }\n          } else {\n            const err = this.__push([obj[objname], obj]);\n\n            if (err) {\n              return err;\n            }\n          }\n        } // Without columns, records are array\n\n      } else {\n        if (raw === true || info === true) {\n          const err = this.__push(Object.assign({\n            record: record\n          }, raw === true ? {\n            raw: this.state.rawBuffer.toString(encoding)\n          } : {}, info === true ? {\n            info: this.__infoRecord()\n          } : {}));\n\n          if (err) {\n            return err;\n          }\n        } else {\n          const err = this.__push(record);\n\n          if (err) {\n            return err;\n          }\n        }\n      }\n    }\n\n    this.__resetRecord();\n  }\n\n  __firstLineToColumns(record) {\n    const {\n      firstLineToHeaders\n    } = this.state;\n\n    try {\n      const headers = firstLineToHeaders === undefined ? record : firstLineToHeaders.call(null, record);\n\n      if (!Array.isArray(headers)) {\n        return this.__error(new CsvError('CSV_INVALID_COLUMN_MAPPING', ['Invalid Column Mapping:', 'expect an array from column function,', `got ${JSON.stringify(headers)}`], this.options, this.__infoField(), {\n          headers: headers\n        }));\n      }\n\n      const normalizedHeaders = normalizeColumnsArray(headers);\n      this.state.expectedRecordLength = normalizedHeaders.length;\n      this.options.columns = normalizedHeaders;\n\n      this.__resetRecord();\n\n      return;\n    } catch (err) {\n      return err;\n    }\n  }\n\n  __resetRecord() {\n    if (this.options.raw === true) {\n      this.state.rawBuffer.reset();\n    }\n\n    this.state.error = undefined;\n    this.state.record = [];\n    this.state.record_length = 0;\n  }\n\n  __onField() {\n    const {\n      cast,\n      encoding,\n      rtrim,\n      max_record_size\n    } = this.options;\n    const {\n      enabled,\n      wasQuoting\n    } = this.state; // Short circuit for the from_line options\n\n    if (enabled === false) {\n      return this.__resetField();\n    }\n\n    let field = this.state.field.toString(encoding);\n\n    if (rtrim === true && wasQuoting === false) {\n      field = field.trimRight();\n    }\n\n    if (cast === true) {\n      const [err, f] = this.__cast(field);\n\n      if (err !== undefined) return err;\n      field = f;\n    }\n\n    this.state.record.push(field); // Increment record length if record size must not exceed a limit\n\n    if (max_record_size !== 0 && typeof field === 'string') {\n      this.state.record_length += field.length;\n    }\n\n    this.__resetField();\n  }\n\n  __resetField() {\n    this.state.field.reset();\n    this.state.wasQuoting = false;\n  }\n\n  __push(record) {\n    const {\n      on_record\n    } = this.options;\n\n    if (on_record !== undefined) {\n      const info = this.__infoRecord();\n\n      try {\n        record = on_record.call(null, record, info);\n      } catch (err) {\n        return err;\n      }\n\n      if (record === undefined || record === null) {\n        return;\n      }\n    }\n\n    this.push(record);\n  } // Return a tuple with the error and the casted value\n\n\n  __cast(field) {\n    const {\n      columns,\n      relax_column_count\n    } = this.options;\n    const isColumns = Array.isArray(columns); // Dont loose time calling cast\n    // because the final record is an object\n    // and this field can't be associated to a key present in columns\n\n    if (isColumns === true && relax_column_count && this.options.columns.length <= this.state.record.length) {\n      return [undefined, undefined];\n    }\n\n    if (this.state.castField !== null) {\n      try {\n        const info = this.__infoField();\n\n        return [undefined, this.state.castField.call(null, field, info)];\n      } catch (err) {\n        return [err];\n      }\n    }\n\n    if (this.__isFloat(field)) {\n      return [undefined, parseFloat(field)];\n    } else if (this.options.cast_date !== false) {\n      const info = this.__infoField();\n\n      return [undefined, this.options.cast_date.call(null, field, info)];\n    }\n\n    return [undefined, field];\n  } // Helper to test if a character is a space or a line delimiter\n\n\n  __isCharTrimable(chr) {\n    return chr === space || chr === tab || chr === cr || chr === nl || chr === np;\n  } // Keep it in case we implement the `cast_int` option\n  // __isInt(value){\n  //   // return Number.isInteger(parseInt(value))\n  //   // return !isNaN( parseInt( obj ) );\n  //   return /^(\\-|\\+)?[1-9][0-9]*$/.test(value)\n  // }\n\n\n  __isFloat(value) {\n    return value - parseFloat(value) + 1 >= 0; // Borrowed from jquery\n  }\n\n  __compareBytes(sourceBuf, targetBuf, targetPos, firstByte) {\n    if (sourceBuf[0] !== firstByte) return 0;\n    const sourceLength = sourceBuf.length;\n\n    for (let i = 1; i < sourceLength; i++) {\n      if (sourceBuf[i] !== targetBuf[targetPos + i]) return 0;\n    }\n\n    return sourceLength;\n  }\n\n  __needMoreData(i, bufLen, end) {\n    if (end) return false;\n    const {\n      quote\n    } = this.options;\n    const {\n      quoting,\n      needMoreDataSize,\n      recordDelimiterMaxLength\n    } = this.state;\n    const numOfCharLeft = bufLen - i - 1;\n    const requiredLength = Math.max(needMoreDataSize, // Skip if the remaining buffer smaller than record delimiter\n    recordDelimiterMaxLength, // Skip if the remaining buffer can be record delimiter following the closing quote\n    // 1 is for quote.length\n    quoting ? quote.length + recordDelimiterMaxLength : 0);\n    return numOfCharLeft < requiredLength;\n  }\n\n  __isDelimiter(buf, pos, chr) {\n    const {\n      delimiter,\n      ignore_last_delimiters\n    } = this.options;\n\n    if (ignore_last_delimiters === true && this.state.record.length === this.options.columns.length - 1) {\n      return 0;\n    } else if (ignore_last_delimiters !== false && typeof ignore_last_delimiters === 'number' && this.state.record.length === ignore_last_delimiters - 1) {\n      return 0;\n    }\n\n    loop1: for (let i = 0; i < delimiter.length; i++) {\n      const del = delimiter[i];\n\n      if (del[0] === chr) {\n        for (let j = 1; j < del.length; j++) {\n          if (del[j] !== buf[pos + j]) continue loop1;\n        }\n\n        return del.length;\n      }\n    }\n\n    return 0;\n  }\n\n  __isRecordDelimiter(chr, buf, pos) {\n    const {\n      record_delimiter\n    } = this.options;\n    const recordDelimiterLength = record_delimiter.length;\n\n    loop1: for (let i = 0; i < recordDelimiterLength; i++) {\n      const rd = record_delimiter[i];\n      const rdLength = rd.length;\n\n      if (rd[0] !== chr) {\n        continue;\n      }\n\n      for (let j = 1; j < rdLength; j++) {\n        if (rd[j] !== buf[pos + j]) {\n          continue loop1;\n        }\n      }\n\n      return rd.length;\n    }\n\n    return 0;\n  }\n\n  __isEscape(buf, pos, chr) {\n    const {\n      escape\n    } = this.options;\n    if (escape === null) return false;\n    const l = escape.length;\n\n    if (escape[0] === chr) {\n      for (let i = 0; i < l; i++) {\n        if (escape[i] !== buf[pos + i]) {\n          return false;\n        }\n      }\n\n      return true;\n    }\n\n    return false;\n  }\n\n  __isQuote(buf, pos) {\n    const {\n      quote\n    } = this.options;\n    if (quote === null) return false;\n    const l = quote.length;\n\n    for (let i = 0; i < l; i++) {\n      if (quote[i] !== buf[pos + i]) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  __autoDiscoverRecordDelimiter(buf, pos) {\n    const {\n      encoding\n    } = this.options;\n    const chr = buf[pos];\n\n    if (chr === cr) {\n      if (buf[pos + 1] === nl) {\n        this.options.record_delimiter.push(Buffer.from('\\r\\n', encoding));\n        this.state.recordDelimiterMaxLength = 2;\n        return 2;\n      } else {\n        this.options.record_delimiter.push(Buffer.from('\\r', encoding));\n        this.state.recordDelimiterMaxLength = 1;\n        return 1;\n      }\n    } else if (chr === nl) {\n      this.options.record_delimiter.push(Buffer.from('\\n', encoding));\n      this.state.recordDelimiterMaxLength = 1;\n      return 1;\n    }\n\n    return 0;\n  }\n\n  __error(msg) {\n    const {\n      skip_lines_with_error\n    } = this.options;\n    const err = typeof msg === 'string' ? new Error(msg) : msg;\n\n    if (skip_lines_with_error) {\n      this.state.recordHasError = true;\n      this.emit('skip', err);\n      return undefined;\n    } else {\n      return err;\n    }\n  }\n\n  __infoDataSet() {\n    return { ...this.info,\n      columns: this.options.columns\n    };\n  }\n\n  __infoRecord() {\n    const {\n      columns\n    } = this.options;\n    return { ...this.__infoDataSet(),\n      error: this.state.error,\n      header: columns === true,\n      index: this.state.record.length\n    };\n  }\n\n  __infoField() {\n    const {\n      columns\n    } = this.options;\n    const isColumns = Array.isArray(columns);\n    return { ...this.__infoRecord(),\n      column: isColumns === true ? columns.length > this.state.record.length ? columns[this.state.record.length].name : null : this.state.record.length,\n      quoting: this.state.wasQuoting\n    };\n  }\n\n}\n\nconst parse = function () {\n  let data, options, callback;\n\n  for (let i in arguments) {\n    const argument = arguments[i];\n    const type = typeof argument;\n\n    if (data === undefined && (typeof argument === 'string' || Buffer.isBuffer(argument))) {\n      data = argument;\n    } else if (options === undefined && isObject(argument)) {\n      options = argument;\n    } else if (callback === undefined && type === 'function') {\n      callback = argument;\n    } else {\n      throw new CsvError('CSV_INVALID_ARGUMENT', ['Invalid argument:', `got ${JSON.stringify(argument)} at index ${i}`], options || {});\n    }\n  }\n\n  const parser = new Parser(options);\n\n  if (callback) {\n    const records = options === undefined || options.objname === undefined ? [] : {};\n    parser.on('readable', function () {\n      let record;\n\n      while ((record = this.read()) !== null) {\n        if (options === undefined || options.objname === undefined) {\n          records.push(record);\n        } else {\n          records[record[0]] = record[1];\n        }\n      }\n    });\n    parser.on('error', function (err) {\n      callback(err, undefined, parser.__infoDataSet());\n    });\n    parser.on('end', function () {\n      callback(undefined, records, parser.__infoDataSet());\n    });\n  }\n\n  if (data !== undefined) {\n    // Give a chance for events to be registered later\n    if (typeof setImmediate === 'function') {\n      setImmediate(function () {\n        parser.write(data);\n        parser.end();\n      });\n    } else {\n      parser.write(data);\n      parser.end();\n    }\n  }\n\n  return parser;\n};\n\nclass CsvError extends Error {\n  constructor(code, message, options) {\n    if (Array.isArray(message)) message = message.join(' ');\n    super(message);\n\n    if (Error.captureStackTrace !== undefined) {\n      Error.captureStackTrace(this, CsvError);\n    }\n\n    this.code = code;\n\n    for (var _len = arguments.length, contexts = new Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) {\n      contexts[_key - 3] = arguments[_key];\n    }\n\n    for (const context of contexts) {\n      for (const key in context) {\n        const value = context[key];\n        this[key] = Buffer.isBuffer(value) ? value.toString(options.encoding) : value == null ? value : JSON.parse(JSON.stringify(value));\n      }\n    }\n  }\n\n}\n\nparse.Parser = Parser;\nparse.CsvError = CsvError;\nmodule.exports = parse;\n\nconst underscore = function (str) {\n  return str.replace(/([A-Z])/g, function (_, match) {\n    return '_' + match.toLowerCase();\n  });\n};\n\nconst isObject = function (obj) {\n  return typeof obj === 'object' && obj !== null && !Array.isArray(obj);\n};\n\nconst isRecordEmpty = function (record) {\n  return record.every(field => field == null || field.toString && field.toString().trim() === '');\n};\n\nconst normalizeColumnsArray = function (columns) {\n  const normalizedColumns = [];\n\n  for (let i = 0, l = columns.length; i < l; i++) {\n    const column = columns[i];\n\n    if (column === undefined || column === null || column === false) {\n      normalizedColumns[i] = {\n        disabled: true\n      };\n    } else if (typeof column === 'string') {\n      normalizedColumns[i] = {\n        name: column\n      };\n    } else if (isObject(column)) {\n      if (typeof column.name !== 'string') {\n        throw new CsvError('CSV_OPTION_COLUMNS_MISSING_NAME', ['Option columns missing name:', `property \"name\" is required at position ${i}`, 'when column is an object literal']);\n      }\n\n      normalizedColumns[i] = column;\n    } else {\n      throw new CsvError('CSV_INVALID_COLUMN_DEFINITION', ['Invalid column definition:', 'expect a string or a literal object,', `got ${JSON.stringify(column)} at position ${i}`]);\n    }\n  }\n\n  return normalizedColumns;\n};","map":{"version":3,"names":["Transform","require","ResizeableBuffer","tab","nl","np","cr","space","boms","Buffer","from","Parser","constructor","opts","readableObjectMode","encoding","__originalOptions","__normalizeOptions","options","opt","underscore","undefined","CsvError","JSON","stringify","bom","fnCastField","cast","cast_date","value","date","Date","parse","isNaN","fnFirstLineToHeaders","columns","Array","isArray","normalizeColumnsArray","columns_duplicates_to_array","comment","isBuffer","delimiter_json","delimiter","length","map","escape","Error","test","parseInt","Number","isInteger","from_line","ignore_last_delimiters","Math","floor","info","max_record_size","objname","toString","on_record","quote","raw","record_delimiter","rd","relax","relax_column_count","relax_column_count_less","relax_column_count_more","skip_empty_lines","skip_lines_with_empty_values","skip_lines_with_error","rtrim","ltrim","trim","to","to_line","bytes","comment_lines","empty_lines","invalid_field_length","lines","records","state","bomSkipped","bufBytesStart","castField","commenting","error","enabled","escaping","escapeIsQuote","compare","expectedRecordLength","field","firstLineToHeaders","needMoreDataSize","max","previousBuf","quoting","stop","rawBuffer","record","recordHasError","record_length","recordDelimiterMaxLength","v","trimChars","wasQuoting","wasRowDelimiter","_transform","buf","callback","err","__parse","_flush","nextBuf","end","push","concat","bomLength","slice","bufLen","pos","__needMoreData","record_delimiterCount","__autoDiscoverRecordDelimiter","chr","append","__isEscape","__isQuote","nextChr","isNextChrTrimable","__isCharTrimable","isNextChrComment","__compareBytes","isNextChrDelimiter","__isDelimiter","isNextChrRecordDelimiter","__isRecordDelimiter","__error","String","fromCharCode","__infoField","prepend","recordDelimiterLength","skipCommentLine","__resetField","__resetRecord","errField","__onField","errRecord","__onRecord","commentCount","delimiterLength","lappend","rappend","recordLength","isRecordEmpty","__firstLineToColumns","finalErr","obj","i","l","disabled","name","__push","Object","assign","__infoRecord","headers","call","normalizedHeaders","reset","trimRight","f","__cast","isColumns","__isFloat","parseFloat","sourceBuf","targetBuf","targetPos","firstByte","sourceLength","numOfCharLeft","requiredLength","loop1","del","j","rdLength","msg","emit","__infoDataSet","header","index","column","data","arguments","argument","type","isObject","parser","on","read","setImmediate","write","code","message","join","captureStackTrace","contexts","context","key","module","exports","str","replace","_","match","toLowerCase","every","normalizedColumns"],"sources":["/Users/waiwai/Desktop/Github/Einstein/testing/node_modules/csv-parse/lib/index.js"],"sourcesContent":["\n/*\nCSV Parse\n\nPlease look at the [project documentation](https://csv.js.org/parse/) for\nadditional information.\n*/\n\nconst { Transform } = require('stream')\nconst ResizeableBuffer = require('./ResizeableBuffer')\n\n// white space characters\n// https://en.wikipedia.org/wiki/Whitespace_character\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions/Character_Classes#Types\n// \\f\\n\\r\\t\\v\\u00a0\\u1680\\u2000-\\u200a\\u2028\\u2029\\u202f\\u205f\\u3000\\ufeff\nconst tab = 9\nconst nl = 10 // \\n, 0x0A in hexadecimal, 10 in decimal\nconst np = 12\nconst cr = 13 // \\r, 0x0D in hexadÃ©cimal, 13 in decimal\nconst space = 32\nconst boms = {\n  // Note, the following are equals:\n  // Buffer.from(\"\\ufeff\")\n  // Buffer.from([239, 187, 191])\n  // Buffer.from('EFBBBF', 'hex')\n  'utf8': Buffer.from([239, 187, 191]),\n  // Note, the following are equals:\n  // Buffer.from \"\\ufeff\", 'utf16le\n  // Buffer.from([255, 254])\n  'utf16le': Buffer.from([255, 254])\n}\n\nclass Parser extends Transform {\n  constructor(opts = {}){\n    super({...{readableObjectMode: true}, ...opts, encoding: null})\n    this.__originalOptions = opts\n    this.__normalizeOptions(opts)\n  }\n  __normalizeOptions(opts){\n    const options = {}\n    // Merge with user options\n    for(let opt in opts){\n      options[underscore(opt)] = opts[opt]\n    }\n    // Normalize option `encoding`\n    // Note: defined first because other options depends on it\n    // to convert chars/strings into buffers.\n    if(options.encoding === undefined || options.encoding === true){\n      options.encoding = 'utf8'\n    }else if(options.encoding === null || options.encoding === false){\n      options.encoding = null\n    }else if(typeof options.encoding !== 'string' && options.encoding !== null){\n      throw new CsvError('CSV_INVALID_OPTION_ENCODING', [\n        'Invalid option encoding:',\n        'encoding must be a string or null to return a buffer,',\n        `got ${JSON.stringify(options.encoding)}`\n      ], options)\n    }\n    // Normalize option `bom`\n    if(options.bom === undefined || options.bom === null || options.bom === false){\n      options.bom = false\n    }else if(options.bom !== true){\n      throw new CsvError('CSV_INVALID_OPTION_BOM', [\n        'Invalid option bom:', 'bom must be true,',\n        `got ${JSON.stringify(options.bom)}`\n      ], options)\n    }\n    // Normalize option `cast`\n    let fnCastField = null\n    if(options.cast === undefined || options.cast === null || options.cast === false || options.cast === ''){\n      options.cast = undefined\n    }else if(typeof options.cast === 'function'){\n      fnCastField = options.cast\n      options.cast = true\n    }else if(options.cast !== true){\n      throw new CsvError('CSV_INVALID_OPTION_CAST', [\n        'Invalid option cast:', 'cast must be true or a function,',\n        `got ${JSON.stringify(options.cast)}`\n      ], options)\n    }\n    // Normalize option `cast_date`\n    if(options.cast_date === undefined || options.cast_date === null || options.cast_date === false || options.cast_date === ''){\n      options.cast_date = false\n    }else if(options.cast_date === true){\n      options.cast_date = function(value){\n        const date = Date.parse(value)\n        return !isNaN(date) ? new Date(date) : value\n      }\n    }else{\n      throw new CsvError('CSV_INVALID_OPTION_CAST_DATE', [\n        'Invalid option cast_date:', 'cast_date must be true or a function,',\n        `got ${JSON.stringify(options.cast_date)}`\n      ], options)\n    }\n    // Normalize option `columns`\n    let fnFirstLineToHeaders = null\n    if(options.columns === true){\n      // Fields in the first line are converted as-is to columns\n      fnFirstLineToHeaders = undefined\n    }else if(typeof options.columns === 'function'){\n      fnFirstLineToHeaders = options.columns\n      options.columns = true\n    }else if(Array.isArray(options.columns)){\n      options.columns = normalizeColumnsArray(options.columns)\n    }else if(options.columns === undefined || options.columns === null || options.columns === false){\n      options.columns = false\n    }else{\n      throw new CsvError('CSV_INVALID_OPTION_COLUMNS', [\n        'Invalid option columns:',\n        'expect an array, a function or true,',\n        `got ${JSON.stringify(options.columns)}`\n      ], options)\n    }\n    // Normalize option `columns_duplicates_to_array`\n    if(options.columns_duplicates_to_array === undefined || options.columns_duplicates_to_array === null || options.columns_duplicates_to_array === false){\n      options.columns_duplicates_to_array = false\n    }else if(options.columns_duplicates_to_array !== true){\n      throw new CsvError('CSV_INVALID_OPTION_COLUMNS_DUPLICATES_TO_ARRAY', [\n        'Invalid option columns_duplicates_to_array:',\n        'expect an boolean,',\n        `got ${JSON.stringify(options.columns_duplicates_to_array)}`\n      ], options)\n    }else if(options.columns === false){\n      throw new CsvError('CSV_INVALID_OPTION_COLUMNS_DUPLICATES_TO_ARRAY', [\n        'Invalid option columns_duplicates_to_array:',\n        'the `columns` mode must be activated.'\n      ], options)\n    }\n    // Normalize option `comment`\n    if(options.comment === undefined || options.comment === null || options.comment === false || options.comment === ''){\n      options.comment = null\n    }else{\n      if(typeof options.comment === 'string'){\n        options.comment = Buffer.from(options.comment, options.encoding)\n      }\n      if(!Buffer.isBuffer(options.comment)){\n        throw new CsvError('CSV_INVALID_OPTION_COMMENT', [\n          'Invalid option comment:',\n          'comment must be a buffer or a string,',\n          `got ${JSON.stringify(options.comment)}`\n        ], options)\n      }\n    }\n    // Normalize option `delimiter`\n    const delimiter_json = JSON.stringify(options.delimiter)\n    if(!Array.isArray(options.delimiter)) options.delimiter = [options.delimiter]\n    if(options.delimiter.length === 0){\n      throw new CsvError('CSV_INVALID_OPTION_DELIMITER', [\n        'Invalid option delimiter:',\n        'delimiter must be a non empty string or buffer or array of string|buffer,',\n        `got ${delimiter_json}`\n      ], options)\n    }\n    options.delimiter = options.delimiter.map(function(delimiter){\n      if(delimiter === undefined || delimiter === null || delimiter === false){\n        return Buffer.from(',', options.encoding)\n      }\n      if(typeof delimiter === 'string'){\n        delimiter = Buffer.from(delimiter, options.encoding)\n      }\n      if( !Buffer.isBuffer(delimiter) || delimiter.length === 0){\n        throw new CsvError('CSV_INVALID_OPTION_DELIMITER', [\n          'Invalid option delimiter:',\n          'delimiter must be a non empty string or buffer or array of string|buffer,',\n          `got ${delimiter_json}`\n        ], options)\n      }\n      return delimiter\n    })\n    // Normalize option `escape`\n    if(options.escape === undefined || options.escape === true){\n      options.escape = Buffer.from('\"', options.encoding)\n    }else if(typeof options.escape === 'string'){\n      options.escape = Buffer.from(options.escape, options.encoding)\n    }else if (options.escape === null || options.escape === false){\n      options.escape = null\n    }\n    if(options.escape !== null){\n      if(!Buffer.isBuffer(options.escape)){\n        throw new Error(`Invalid Option: escape must be a buffer, a string or a boolean, got ${JSON.stringify(options.escape)}`)\n      }\n    }\n    // Normalize option `from`\n    if(options.from === undefined || options.from === null){\n      options.from = 1\n    }else{\n      if(typeof options.from === 'string' && /\\d+/.test(options.from)){\n        options.from = parseInt(options.from)\n      }\n      if(Number.isInteger(options.from)){\n        if(options.from < 0){\n          throw new Error(`Invalid Option: from must be a positive integer, got ${JSON.stringify(opts.from)}`)\n        }\n      }else{\n        throw new Error(`Invalid Option: from must be an integer, got ${JSON.stringify(options.from)}`)\n      }\n    }\n    // Normalize option `from_line`\n    if(options.from_line === undefined || options.from_line === null){\n      options.from_line = 1\n    }else{\n      if(typeof options.from_line === 'string' && /\\d+/.test(options.from_line)){\n        options.from_line = parseInt(options.from_line)\n      }\n      if(Number.isInteger(options.from_line)){\n        if(options.from_line <= 0){\n          throw new Error(`Invalid Option: from_line must be a positive integer greater than 0, got ${JSON.stringify(opts.from_line)}`)\n        }\n      }else{\n        throw new Error(`Invalid Option: from_line must be an integer, got ${JSON.stringify(opts.from_line)}`)\n      }\n    }\n    // Normalize options `ignore_last_delimiters`\n    if(options.ignore_last_delimiters === undefined || options.ignore_last_delimiters === null){\n      options.ignore_last_delimiters = false\n    }else if(typeof options.ignore_last_delimiters === 'number'){\n      options.ignore_last_delimiters = Math.floor(options.ignore_last_delimiters)\n      if(options.ignore_last_delimiters === 0){\n        options.ignore_last_delimiters = false\n      }\n    }else if(typeof options.ignore_last_delimiters !== 'boolean'){\n      throw new CsvError('CSV_INVALID_OPTION_IGNORE_LAST_DELIMITERS', [\n        'Invalid option `ignore_last_delimiters`:',\n        'the value must be a boolean value or an integer,',\n        `got ${JSON.stringify(options.ignore_last_delimiters)}`\n      ], options)\n    }\n    if(options.ignore_last_delimiters === true && options.columns === false){\n      throw new CsvError('CSV_IGNORE_LAST_DELIMITERS_REQUIRES_COLUMNS', [\n        'The option `ignore_last_delimiters`',\n        'requires the activation of the `columns` option'\n      ], options)\n    }\n    // Normalize option `info`\n    if(options.info === undefined || options.info === null || options.info === false){\n      options.info = false\n    }else if(options.info !== true){\n      throw new Error(`Invalid Option: info must be true, got ${JSON.stringify(options.info)}`)\n    }\n    // Normalize option `max_record_size`\n    if(options.max_record_size === undefined || options.max_record_size === null || options.max_record_size === false){\n      options.max_record_size = 0\n    }else if(Number.isInteger(options.max_record_size) && options.max_record_size >= 0){\n      // Great, nothing to do\n    }else if(typeof options.max_record_size === 'string' && /\\d+/.test(options.max_record_size)){\n      options.max_record_size = parseInt(options.max_record_size)\n    }else{\n      throw new Error(`Invalid Option: max_record_size must be a positive integer, got ${JSON.stringify(options.max_record_size)}`)\n    }\n    // Normalize option `objname`\n    if(options.objname === undefined || options.objname === null || options.objname === false){\n      options.objname = undefined\n    }else if(Buffer.isBuffer(options.objname)){\n      if(options.objname.length === 0){\n        throw new Error(`Invalid Option: objname must be a non empty buffer`)\n      }\n      if(options.encoding === null){\n        // Don't call `toString`, leave objname as a buffer\n      }else{\n        options.objname = options.objname.toString(options.encoding)\n      }\n    }else if(typeof options.objname === 'string'){\n      if(options.objname.length === 0){\n        throw new Error(`Invalid Option: objname must be a non empty string`)\n      }\n      // Great, nothing to do\n    }else{\n      throw new Error(`Invalid Option: objname must be a string or a buffer, got ${options.objname}`)\n    }\n    // Normalize option `on_record`\n    if(options.on_record === undefined || options.on_record === null){\n      options.on_record = undefined\n    }else if(typeof options.on_record !== 'function'){\n      throw new CsvError('CSV_INVALID_OPTION_ON_RECORD', [\n        'Invalid option `on_record`:',\n        'expect a function,',\n        `got ${JSON.stringify(options.on_record)}`\n      ], options)\n    }\n    // Normalize option `quote`\n    if(options.quote === null || options.quote === false || options.quote === ''){\n      options.quote = null\n    }else{\n      if(options.quote === undefined || options.quote === true){\n        options.quote = Buffer.from('\"', options.encoding)\n      }else if(typeof options.quote === 'string'){\n        options.quote = Buffer.from(options.quote, options.encoding)\n      }\n      if(!Buffer.isBuffer(options.quote)){\n        throw new Error(`Invalid Option: quote must be a buffer or a string, got ${JSON.stringify(options.quote)}`)\n      }\n    }\n    // Normalize option `raw`\n    if(options.raw === undefined || options.raw === null || options.raw === false){\n      options.raw = false\n    }else if(options.raw !== true){\n      throw new Error(`Invalid Option: raw must be true, got ${JSON.stringify(options.raw)}`)\n    }\n    // Normalize option `record_delimiter`\n    if(!options.record_delimiter){\n      options.record_delimiter = []\n    }else if(!Array.isArray(options.record_delimiter)){\n      options.record_delimiter = [options.record_delimiter]\n    }\n    options.record_delimiter = options.record_delimiter.map( function(rd){\n      if(typeof rd === 'string'){\n        rd = Buffer.from(rd, options.encoding)\n      }\n      return rd\n    })\n    // Normalize option `relax`\n    if(typeof options.relax === 'boolean'){\n      // Great, nothing to do\n    }else if(options.relax === undefined || options.relax === null){\n      options.relax = false\n    }else{\n      throw new Error(`Invalid Option: relax must be a boolean, got ${JSON.stringify(options.relax)}`)\n    }\n    // Normalize option `relax_column_count`\n    if(typeof options.relax_column_count === 'boolean'){\n      // Great, nothing to do\n    }else if(options.relax_column_count === undefined || options.relax_column_count === null){\n      options.relax_column_count = false\n    }else{\n      throw new Error(`Invalid Option: relax_column_count must be a boolean, got ${JSON.stringify(options.relax_column_count)}`)\n    }\n    if(typeof options.relax_column_count_less === 'boolean'){\n      // Great, nothing to do\n    }else if(options.relax_column_count_less === undefined || options.relax_column_count_less === null){\n      options.relax_column_count_less = false\n    }else{\n      throw new Error(`Invalid Option: relax_column_count_less must be a boolean, got ${JSON.stringify(options.relax_column_count_less)}`)\n    }\n    if(typeof options.relax_column_count_more === 'boolean'){\n      // Great, nothing to do\n    }else if(options.relax_column_count_more === undefined || options.relax_column_count_more === null){\n      options.relax_column_count_more = false\n    }else{\n      throw new Error(`Invalid Option: relax_column_count_more must be a boolean, got ${JSON.stringify(options.relax_column_count_more)}`)\n    }\n    // Normalize option `skip_empty_lines`\n    if(typeof options.skip_empty_lines === 'boolean'){\n      // Great, nothing to do\n    }else if(options.skip_empty_lines === undefined || options.skip_empty_lines === null){\n      options.skip_empty_lines = false\n    }else{\n      throw new Error(`Invalid Option: skip_empty_lines must be a boolean, got ${JSON.stringify(options.skip_empty_lines)}`)\n    }\n    // Normalize option `skip_lines_with_empty_values`\n    if(typeof options.skip_lines_with_empty_values === 'boolean'){\n      // Great, nothing to do\n    }else if(options.skip_lines_with_empty_values === undefined || options.skip_lines_with_empty_values === null){\n      options.skip_lines_with_empty_values = false\n    }else{\n      throw new Error(`Invalid Option: skip_lines_with_empty_values must be a boolean, got ${JSON.stringify(options.skip_lines_with_empty_values)}`)\n    }\n    // Normalize option `skip_lines_with_error`\n    if(typeof options.skip_lines_with_error === 'boolean'){\n      // Great, nothing to do\n    }else if(options.skip_lines_with_error === undefined || options.skip_lines_with_error === null){\n      options.skip_lines_with_error = false\n    }else{\n      throw new Error(`Invalid Option: skip_lines_with_error must be a boolean, got ${JSON.stringify(options.skip_lines_with_error)}`)\n    }\n    // Normalize option `rtrim`\n    if(options.rtrim === undefined || options.rtrim === null || options.rtrim === false){\n      options.rtrim = false\n    }else if(options.rtrim !== true){\n      throw new Error(`Invalid Option: rtrim must be a boolean, got ${JSON.stringify(options.rtrim)}`)\n    }\n    // Normalize option `ltrim`\n    if(options.ltrim === undefined || options.ltrim === null || options.ltrim === false){\n      options.ltrim = false\n    }else if(options.ltrim !== true){\n      throw new Error(`Invalid Option: ltrim must be a boolean, got ${JSON.stringify(options.ltrim)}`)\n    }\n    // Normalize option `trim`\n    if(options.trim === undefined || options.trim === null || options.trim === false){\n      options.trim = false\n    }else if(options.trim !== true){\n      throw new Error(`Invalid Option: trim must be a boolean, got ${JSON.stringify(options.trim)}`)\n    }\n    // Normalize options `trim`, `ltrim` and `rtrim`\n    if(options.trim === true && opts.ltrim !== false){\n      options.ltrim = true\n    }else if(options.ltrim !== true){\n      options.ltrim = false\n    }\n    if(options.trim === true && opts.rtrim !== false){\n      options.rtrim = true\n    }else if(options.rtrim !== true){\n      options.rtrim = false\n    }\n    // Normalize option `to`\n    if(options.to === undefined || options.to === null){\n      options.to = -1\n    }else{\n      if(typeof options.to === 'string' && /\\d+/.test(options.to)){\n        options.to = parseInt(options.to)\n      }\n      if(Number.isInteger(options.to)){\n        if(options.to <= 0){\n          throw new Error(`Invalid Option: to must be a positive integer greater than 0, got ${JSON.stringify(opts.to)}`)\n        }\n      }else{\n        throw new Error(`Invalid Option: to must be an integer, got ${JSON.stringify(opts.to)}`)\n      }\n    }\n    // Normalize option `to_line`\n    if(options.to_line === undefined || options.to_line === null){\n      options.to_line = -1\n    }else{\n      if(typeof options.to_line === 'string' && /\\d+/.test(options.to_line)){\n        options.to_line = parseInt(options.to_line)\n      }\n      if(Number.isInteger(options.to_line)){\n        if(options.to_line <= 0){\n          throw new Error(`Invalid Option: to_line must be a positive integer greater than 0, got ${JSON.stringify(opts.to_line)}`)\n        }\n      }else{\n        throw new Error(`Invalid Option: to_line must be an integer, got ${JSON.stringify(opts.to_line)}`)\n      }\n    }\n    this.info = {\n      bytes: 0,\n      comment_lines: 0,\n      empty_lines: 0,\n      invalid_field_length: 0,\n      lines: 1,\n      records: 0\n    }\n    this.options = options\n    this.state = {\n      bomSkipped: false,\n      bufBytesStart: 0,\n      castField: fnCastField,\n      commenting: false,\n      // Current error encountered by a record\n      error: undefined,\n      enabled: options.from_line === 1,\n      escaping: false,\n      // escapeIsQuote: options.escape === options.quote,\n      escapeIsQuote: Buffer.isBuffer(options.escape) && Buffer.isBuffer(options.quote) && Buffer.compare(options.escape, options.quote) === 0,\n      // columns can be `false`, `true`, `Array`\n      expectedRecordLength: Array.isArray(options.columns) ? options.columns.length : undefined,\n      field: new ResizeableBuffer(20),\n      firstLineToHeaders: fnFirstLineToHeaders,\n      needMoreDataSize: Math.max(\n        // Skip if the remaining buffer smaller than comment\n        options.comment !== null ? options.comment.length : 0,\n        // Skip if the remaining buffer can be delimiter\n        ...options.delimiter.map( (delimiter) => delimiter.length),\n        // Skip if the remaining buffer can be escape sequence\n        options.quote !== null ? options.quote.length : 0,\n      ),\n      previousBuf: undefined,\n      quoting: false,\n      stop: false,\n      rawBuffer: new ResizeableBuffer(100),\n      record: [],\n      recordHasError: false,\n      record_length: 0,\n      recordDelimiterMaxLength: options.record_delimiter.length === 0 ? 2 : Math.max(...options.record_delimiter.map( (v) => v.length)),\n      trimChars: [Buffer.from(' ', options.encoding)[0], Buffer.from('\\t', options.encoding)[0]],\n      wasQuoting: false,\n      wasRowDelimiter: false\n    }\n  }\n  // Implementation of `Transform._transform`\n  _transform(buf, encoding, callback){\n    if(this.state.stop === true){\n      return\n    }\n    const err = this.__parse(buf, false)\n    if(err !== undefined){\n      this.state.stop = true\n    }\n    callback(err)\n  }\n  // Implementation of `Transform._flush`\n  _flush(callback){\n    if(this.state.stop === true){\n      return\n    }\n    const err = this.__parse(undefined, true)\n    callback(err)\n  }\n  // Central parser implementation\n  __parse(nextBuf, end){\n    const {bom, comment, escape, from_line, ltrim, max_record_size, quote, raw, relax, rtrim, skip_empty_lines, to, to_line} = this.options\n    let {record_delimiter} = this.options\n    const {bomSkipped, previousBuf, rawBuffer, escapeIsQuote} = this.state\n    let buf\n    if(previousBuf === undefined){\n      if(nextBuf === undefined){\n        // Handle empty string\n        this.push(null)\n        return\n      }else{\n        buf = nextBuf\n      }\n    }else if(previousBuf !== undefined && nextBuf === undefined){\n      buf = previousBuf\n    }else{\n      buf = Buffer.concat([previousBuf, nextBuf])\n    }\n    // Handle UTF BOM\n    if(bomSkipped === false){\n      if(bom === false){\n        this.state.bomSkipped = true\n      }else if(buf.length < 3){\n        // No enough data\n        if(end === false){\n          // Wait for more data\n          this.state.previousBuf = buf\n          return\n        }\n      }else{\n        for(let encoding in boms){\n          if(boms[encoding].compare(buf, 0, boms[encoding].length) === 0){\n            // Skip BOM\n            let bomLength = boms[encoding].length\n            this.state.bufBytesStart += bomLength\n            buf = buf.slice(bomLength)\n            // Renormalize original options with the new encoding\n            this.__normalizeOptions({...this.__originalOptions, encoding: encoding})\n            break\n          }\n        }\n        this.state.bomSkipped = true\n      }\n    }\n    const bufLen = buf.length\n    let pos\n    for(pos = 0; pos < bufLen; pos++){\n      // Ensure we get enough space to look ahead\n      // There should be a way to move this out of the loop\n      if(this.__needMoreData(pos, bufLen, end)){\n        break\n      }\n      if(this.state.wasRowDelimiter === true){\n        this.info.lines++\n        this.state.wasRowDelimiter = false\n      }\n      if(to_line !== -1 && this.info.lines > to_line){\n        this.state.stop = true\n        this.push(null)\n        return\n      }\n      // Auto discovery of record_delimiter, unix, mac and windows supported\n      if(this.state.quoting === false && record_delimiter.length === 0){\n        const record_delimiterCount = this.__autoDiscoverRecordDelimiter(buf, pos)\n        if(record_delimiterCount){\n          record_delimiter = this.options.record_delimiter\n        }\n      }\n      const chr = buf[pos]\n      if(raw === true){\n        rawBuffer.append(chr)\n      }\n      if((chr === cr || chr === nl) && this.state.wasRowDelimiter === false ){\n        this.state.wasRowDelimiter = true\n      }\n      // Previous char was a valid escape char\n      // treat the current char as a regular char\n      if(this.state.escaping === true){\n        this.state.escaping = false\n      }else{\n        // Escape is only active inside quoted fields\n        // We are quoting, the char is an escape chr and there is a chr to escape\n        // if(escape !== null && this.state.quoting === true && chr === escape && pos + 1 < bufLen){\n        if(escape !== null && this.state.quoting === true && this.__isEscape(buf, pos, chr) && pos + escape.length < bufLen){\n          if(escapeIsQuote){\n            if(this.__isQuote(buf, pos+escape.length)){\n              this.state.escaping = true\n              pos += escape.length - 1\n              continue\n            }\n          }else{\n            this.state.escaping = true\n            pos += escape.length - 1\n            continue\n          }\n        }\n        // Not currently escaping and chr is a quote\n        // TODO: need to compare bytes instead of single char\n        if(this.state.commenting === false && this.__isQuote(buf, pos)){\n          if(this.state.quoting === true){\n            const nextChr = buf[pos+quote.length]\n            const isNextChrTrimable = rtrim && this.__isCharTrimable(nextChr)\n            const isNextChrComment = comment !== null && this.__compareBytes(comment, buf, pos+quote.length, nextChr)\n            const isNextChrDelimiter = this.__isDelimiter(buf, pos+quote.length, nextChr)\n            const isNextChrRecordDelimiter = record_delimiter.length === 0 ? this.__autoDiscoverRecordDelimiter(buf, pos+quote.length) : this.__isRecordDelimiter(nextChr, buf, pos+quote.length)\n            // Escape a quote\n            // Treat next char as a regular character\n            if(escape !== null && this.__isEscape(buf, pos, chr) && this.__isQuote(buf, pos + escape.length)){\n              pos += escape.length - 1\n            }else if(!nextChr || isNextChrDelimiter || isNextChrRecordDelimiter || isNextChrComment || isNextChrTrimable){\n              this.state.quoting = false\n              this.state.wasQuoting = true\n              pos += quote.length - 1\n              continue\n            }else if(relax === false){\n              const err = this.__error(\n                new CsvError('CSV_INVALID_CLOSING_QUOTE', [\n                  'Invalid Closing Quote:',\n                  `got \"${String.fromCharCode(nextChr)}\"`,\n                  `at line ${this.info.lines}`,\n                  'instead of delimiter, record delimiter, trimable character',\n                  '(if activated) or comment',\n                ], this.options, this.__infoField())\n              )\n              if(err !== undefined) return err\n            }else{\n              this.state.quoting = false\n              this.state.wasQuoting = true\n              this.state.field.prepend(quote)\n              pos += quote.length - 1\n            }\n          }else{\n            if(this.state.field.length !== 0){\n              // In relax mode, treat opening quote preceded by chrs as regular\n              if( relax === false ){\n                const err = this.__error(\n                  new CsvError('INVALID_OPENING_QUOTE', [\n                    'Invalid Opening Quote:',\n                    `a quote is found inside a field at line ${this.info.lines}`,\n                  ], this.options, this.__infoField(), {\n                    field: this.state.field,\n                  })\n                )\n                if(err !== undefined) return err\n              }\n            }else{\n              this.state.quoting = true\n              pos += quote.length - 1\n              continue\n            }\n          }\n        }\n        if(this.state.quoting === false){\n          let recordDelimiterLength = this.__isRecordDelimiter(chr, buf, pos)\n          if(recordDelimiterLength !== 0){\n            // Do not emit comments which take a full line\n            const skipCommentLine = this.state.commenting && (this.state.wasQuoting === false && this.state.record.length === 0 && this.state.field.length === 0)\n            if(skipCommentLine){\n              this.info.comment_lines++\n              // Skip full comment line\n            }else{\n              // Activate records emition if above from_line\n              if(this.state.enabled === false && this.info.lines + (this.state.wasRowDelimiter === true ? 1: 0) >= from_line){\n                this.state.enabled = true\n                this.__resetField()\n                this.__resetRecord()\n                pos += recordDelimiterLength - 1\n                continue\n              }\n              // Skip if line is empty and skip_empty_lines activated\n              if(skip_empty_lines === true && this.state.wasQuoting === false && this.state.record.length === 0 && this.state.field.length === 0){\n                this.info.empty_lines++\n                pos += recordDelimiterLength - 1\n                continue\n              }\n              this.info.bytes = this.state.bufBytesStart + pos;\n              const errField = this.__onField()\n              if(errField !== undefined) return errField\n              this.info.bytes = this.state.bufBytesStart + pos + recordDelimiterLength;\n              const errRecord = this.__onRecord()\n              if(errRecord !== undefined) return errRecord\n              if(to !== -1 && this.info.records >= to){\n                this.state.stop = true\n                this.push(null)\n                return\n              }\n            }\n            this.state.commenting = false\n            pos += recordDelimiterLength - 1\n            continue\n          }\n          if(this.state.commenting){\n            continue\n          }\n          const commentCount = comment === null ? 0 : this.__compareBytes(comment, buf, pos, chr)\n          if(commentCount !== 0){\n            this.state.commenting = true\n            continue\n          }\n          let delimiterLength = this.__isDelimiter(buf, pos, chr)\n          if(delimiterLength !== 0){\n            this.info.bytes = this.state.bufBytesStart + pos;\n            const errField = this.__onField()\n            if(errField !== undefined) return errField\n            pos += delimiterLength - 1\n            continue\n          }\n        }\n      }\n      if(this.state.commenting === false){\n        if(max_record_size !== 0 && this.state.record_length + this.state.field.length > max_record_size){\n          const err = this.__error(\n            new CsvError('CSV_MAX_RECORD_SIZE', [\n              'Max Record Size:',\n              'record exceed the maximum number of tolerated bytes',\n              `of ${max_record_size}`,\n              `at line ${this.info.lines}`,\n            ], this.options, this.__infoField())\n          )\n          if(err !== undefined) return err\n        }\n      }\n      const lappend = ltrim === false || this.state.quoting === true || this.state.field.length !== 0 || !this.__isCharTrimable(chr)\n      // rtrim in non quoting is handle in __onField\n      const rappend = rtrim === false || this.state.wasQuoting === false\n      if( lappend === true && rappend === true ){\n        this.state.field.append(chr)\n      }else if(rtrim === true && !this.__isCharTrimable(chr)){\n        const err = this.__error(\n          new CsvError('CSV_NON_TRIMABLE_CHAR_AFTER_CLOSING_QUOTE', [\n            'Invalid Closing Quote:',\n            'found non trimable byte after quote',\n            `at line ${this.info.lines}`,\n          ], this.options, this.__infoField())\n        )\n        if(err !== undefined) return err\n      }\n    }\n    if(end === true){\n      // Ensure we are not ending in a quoting state\n      if(this.state.quoting === true){\n        const err = this.__error(\n          new CsvError('CSV_QUOTE_NOT_CLOSED', [\n            'Quote Not Closed:',\n            `the parsing is finished with an opening quote at line ${this.info.lines}`,\n          ], this.options, this.__infoField())\n        )\n        if(err !== undefined) return err\n      }else{\n        // Skip last line if it has no characters\n        if(this.state.wasQuoting === true || this.state.record.length !== 0 || this.state.field.length !== 0){\n          this.info.bytes = this.state.bufBytesStart + pos;\n          const errField = this.__onField()\n          if(errField !== undefined) return errField\n          const errRecord = this.__onRecord()\n          if(errRecord !== undefined) return errRecord\n        }else if(this.state.wasRowDelimiter === true){\n          this.info.empty_lines++\n        }else if(this.state.commenting === true){\n          this.info.comment_lines++\n        }\n      }\n    }else{\n      this.state.bufBytesStart += pos\n      this.state.previousBuf = buf.slice(pos)\n    }\n    if(this.state.wasRowDelimiter === true){\n      this.info.lines++\n      this.state.wasRowDelimiter = false\n    }\n  }\n  __onRecord(){\n    const {columns, columns_duplicates_to_array, encoding, info, from, relax_column_count, relax_column_count_less, relax_column_count_more, raw, skip_lines_with_empty_values} = this.options\n    const {enabled, record} = this.state\n    if(enabled === false){\n      return this.__resetRecord()\n    }\n    // Convert the first line into column names\n    const recordLength = record.length\n    if(columns === true){\n      if(skip_lines_with_empty_values === true && isRecordEmpty(record)){\n        this.__resetRecord()\n        return\n      }\n      return this.__firstLineToColumns(record)\n    }\n    if(columns === false && this.info.records === 0){\n      this.state.expectedRecordLength = recordLength\n    }\n    if(recordLength !== this.state.expectedRecordLength){\n      const err = columns === false ?\n        // Todo: rename CSV_INCONSISTENT_RECORD_LENGTH to\n        // CSV_RECORD_INCONSISTENT_FIELDS_LENGTH\n        new CsvError('CSV_INCONSISTENT_RECORD_LENGTH', [\n          'Invalid Record Length:',\n          `expect ${this.state.expectedRecordLength},`,\n          `got ${recordLength} on line ${this.info.lines}`,\n        ], this.options, this.__infoField(), {\n          record: record,\n        })\n      :\n        // Todo: rename CSV_RECORD_DONT_MATCH_COLUMNS_LENGTH to\n        // CSV_RECORD_INCONSISTENT_COLUMNS\n        new CsvError('CSV_RECORD_DONT_MATCH_COLUMNS_LENGTH', [\n          'Invalid Record Length:',\n          `columns length is ${columns.length},`, // rename columns\n          `got ${recordLength} on line ${this.info.lines}`,\n        ], this.options, this.__infoField(), {\n          record: record,\n        })\n      if(relax_column_count === true ||\n        (relax_column_count_less === true && recordLength < this.state.expectedRecordLength) ||\n        (relax_column_count_more === true && recordLength > this.state.expectedRecordLength) ){\n        this.info.invalid_field_length++\n        this.state.error = err\n      // Error is undefined with skip_lines_with_error\n      }else{\n        const finalErr = this.__error(err)\n        if(finalErr) return finalErr\n      }\n    }\n    if(skip_lines_with_empty_values === true && isRecordEmpty(record)){\n      this.__resetRecord()\n      return\n    }\n    if(this.state.recordHasError === true){\n      this.__resetRecord()\n      this.state.recordHasError = false\n      return\n    }\n    this.info.records++\n    if(from === 1 || this.info.records >= from){\n      // With columns, records are object\n      if(columns !== false){\n        const obj = {}\n        // Transform record array to an object\n        for(let i = 0, l = record.length; i < l; i++){\n          if(columns[i] === undefined || columns[i].disabled) continue\n          // Turn duplicate columns into an array\n          if (columns_duplicates_to_array === true && obj[columns[i].name] !== undefined) {\n            if (Array.isArray(obj[columns[i].name])) {\n              obj[columns[i].name] = obj[columns[i].name].concat(record[i])\n            } else {\n              obj[columns[i].name] = [obj[columns[i].name], record[i]]\n            }\n          } else {\n            obj[columns[i].name] = record[i]\n          }\n        }\n        const {objname} = this.options\n        // Without objname (default)\n        if(objname === undefined){\n          if(raw === true || info === true){\n            const err = this.__push(Object.assign(\n              {record: obj},\n              (raw === true ? {raw: this.state.rawBuffer.toString(encoding)}: {}),\n              (info === true ? {info: this.__infoRecord()}: {})\n            ))\n            if(err){\n              return err\n            }\n          }else{\n            const err = this.__push(obj)\n            if(err){\n              return err\n            }\n          }\n        // With objname (default)\n        }else{\n          if(raw === true || info === true){\n            const err = this.__push(Object.assign(\n              {record: [obj[objname], obj]},\n              raw === true ? {raw: this.state.rawBuffer.toString(encoding)}: {},\n              info === true ? {info: this.__infoRecord()}: {}\n            ))\n            if(err){\n              return err\n            }\n          }else{\n            const err = this.__push([obj[objname], obj])\n            if(err){\n              return err\n            }\n          }\n        }\n      // Without columns, records are array\n      }else{\n        if(raw === true || info === true){\n          const err = this.__push(Object.assign(\n            {record: record},\n            raw === true ? {raw: this.state.rawBuffer.toString(encoding)}: {},\n            info === true ? {info: this.__infoRecord()}: {}\n          ))\n          if(err){\n            return err\n          }\n        }else{\n          const err = this.__push(record)\n          if(err){\n            return err\n          }\n        }\n      }\n    }\n    this.__resetRecord()\n  }\n  __firstLineToColumns(record){\n    const {firstLineToHeaders} = this.state\n    try{\n      const headers = firstLineToHeaders === undefined ? record : firstLineToHeaders.call(null, record)\n      if(!Array.isArray(headers)){\n        return this.__error(\n          new CsvError('CSV_INVALID_COLUMN_MAPPING', [\n            'Invalid Column Mapping:',\n            'expect an array from column function,',\n            `got ${JSON.stringify(headers)}`\n          ], this.options, this.__infoField(), {\n            headers: headers,\n          })\n        )\n      }\n      const normalizedHeaders = normalizeColumnsArray(headers)\n      this.state.expectedRecordLength = normalizedHeaders.length\n      this.options.columns = normalizedHeaders\n      this.__resetRecord()\n      return\n    }catch(err){\n      return err\n    }\n  }\n  __resetRecord(){\n    if(this.options.raw === true){\n      this.state.rawBuffer.reset()\n    }\n    this.state.error = undefined\n    this.state.record = []\n    this.state.record_length = 0\n  }\n  __onField(){\n    const {cast, encoding, rtrim, max_record_size} = this.options\n    const {enabled, wasQuoting} = this.state\n    // Short circuit for the from_line options\n    if(enabled === false){\n      return this.__resetField()\n    }\n    let field = this.state.field.toString(encoding)\n    if(rtrim === true && wasQuoting === false){\n      field = field.trimRight()\n    }\n    if(cast === true){\n      const [err, f] = this.__cast(field)\n      if(err !== undefined) return err\n      field = f\n    }\n    this.state.record.push(field)\n    // Increment record length if record size must not exceed a limit\n    if(max_record_size !== 0 && typeof field === 'string'){\n      this.state.record_length += field.length\n    }\n    this.__resetField()\n  }\n  __resetField(){\n    this.state.field.reset()\n    this.state.wasQuoting = false\n  }\n  __push(record){\n    const {on_record} = this.options\n    if(on_record !== undefined){\n      const info = this.__infoRecord()\n      try{\n        record = on_record.call(null, record, info)\n      }catch(err){\n        return err\n      }\n      if(record === undefined || record === null){ return }\n    }\n    this.push(record)\n  }\n  // Return a tuple with the error and the casted value\n  __cast(field){\n    const {columns, relax_column_count} = this.options\n    const isColumns = Array.isArray(columns)\n    // Dont loose time calling cast\n    // because the final record is an object\n    // and this field can't be associated to a key present in columns\n    if( isColumns === true && relax_column_count && this.options.columns.length <= this.state.record.length ){\n      return [undefined, undefined]\n    }\n    if(this.state.castField !== null){\n      try{\n        const info = this.__infoField()\n        return [undefined, this.state.castField.call(null, field, info)]\n      }catch(err){\n        return [err]\n      }\n    }\n    if(this.__isFloat(field)){\n      return [undefined, parseFloat(field)]\n    }else if(this.options.cast_date !== false){\n      const info = this.__infoField()\n      return [undefined, this.options.cast_date.call(null, field, info)]\n    }\n    return [undefined, field]\n  }\n  // Helper to test if a character is a space or a line delimiter\n  __isCharTrimable(chr){\n    return chr === space || chr === tab || chr === cr || chr === nl || chr === np\n  }\n  // Keep it in case we implement the `cast_int` option\n  // __isInt(value){\n  //   // return Number.isInteger(parseInt(value))\n  //   // return !isNaN( parseInt( obj ) );\n  //   return /^(\\-|\\+)?[1-9][0-9]*$/.test(value)\n  // }\n  __isFloat(value){\n    return (value - parseFloat( value ) + 1) >= 0 // Borrowed from jquery\n  }\n  __compareBytes(sourceBuf, targetBuf, targetPos, firstByte){\n    if(sourceBuf[0] !== firstByte) return 0\n    const sourceLength = sourceBuf.length\n    for(let i = 1; i < sourceLength; i++){\n      if(sourceBuf[i] !== targetBuf[targetPos+i]) return 0\n    }\n    return sourceLength\n  }\n  __needMoreData(i, bufLen, end){\n    if(end) return false\n    const {quote} = this.options\n    const {quoting, needMoreDataSize, recordDelimiterMaxLength} = this.state\n    const numOfCharLeft = bufLen - i - 1\n    const requiredLength = Math.max(\n      needMoreDataSize,\n      // Skip if the remaining buffer smaller than record delimiter\n      recordDelimiterMaxLength,\n      // Skip if the remaining buffer can be record delimiter following the closing quote\n      // 1 is for quote.length\n      quoting ? (quote.length + recordDelimiterMaxLength) : 0,\n    )\n    return numOfCharLeft < requiredLength\n  }\n  __isDelimiter(buf, pos, chr){\n    const {delimiter, ignore_last_delimiters} = this.options\n    if(ignore_last_delimiters === true && this.state.record.length === this.options.columns.length - 1){\n      return 0\n    }else if(ignore_last_delimiters !== false && typeof ignore_last_delimiters === 'number' && this.state.record.length === ignore_last_delimiters - 1){\n      return 0\n    }\n    loop1: for(let i = 0; i < delimiter.length; i++){\n      const del = delimiter[i]\n      if(del[0] === chr){\n        for(let j = 1; j < del.length; j++){\n          if(del[j] !== buf[pos+j]) continue loop1\n        }\n        return del.length\n      }\n    }\n    return 0\n  }\n  __isRecordDelimiter(chr, buf, pos){\n    const {record_delimiter} = this.options\n    const recordDelimiterLength = record_delimiter.length\n    loop1: for(let i = 0; i < recordDelimiterLength; i++){\n      const rd = record_delimiter[i]\n      const rdLength = rd.length\n      if(rd[0] !== chr){\n        continue\n      }\n      for(let j = 1; j < rdLength; j++){\n        if(rd[j] !== buf[pos+j]){\n          continue loop1\n        }\n      }\n      return rd.length\n    }\n    return 0\n  }\n  __isEscape(buf, pos, chr){\n    const {escape} = this.options\n    if(escape === null) return false\n    const l = escape.length\n    if(escape[0] === chr){\n      for(let i = 0; i < l; i++){\n        if(escape[i] !== buf[pos+i]){\n          return false\n        }\n      }\n      return true\n    }\n    return false\n  }\n  __isQuote(buf, pos){\n    const {quote} = this.options\n    if(quote === null) return false\n    const l = quote.length\n    for(let i = 0; i < l; i++){\n      if(quote[i] !== buf[pos+i]){\n        return false\n      }\n    }\n    return true\n  }\n  __autoDiscoverRecordDelimiter(buf, pos){\n    const {encoding} = this.options\n    const chr = buf[pos]\n    if(chr === cr){\n      if(buf[pos+1] === nl){\n        this.options.record_delimiter.push(Buffer.from('\\r\\n', encoding))\n        this.state.recordDelimiterMaxLength = 2\n        return 2\n      }else{\n        this.options.record_delimiter.push(Buffer.from('\\r', encoding))\n        this.state.recordDelimiterMaxLength = 1\n        return 1\n      }\n    }else if(chr === nl){\n      this.options.record_delimiter.push(Buffer.from('\\n', encoding))\n      this.state.recordDelimiterMaxLength = 1\n      return 1\n    }\n    return 0\n  }\n  __error(msg){\n    const {skip_lines_with_error} = this.options\n    const err = typeof msg === 'string' ? new Error(msg) : msg\n    if(skip_lines_with_error){\n      this.state.recordHasError = true\n      this.emit('skip', err)\n      return undefined\n    }else{\n      return err\n    }\n  }\n  __infoDataSet(){\n    return {\n      ...this.info,\n      columns: this.options.columns\n    }\n  }\n  __infoRecord(){\n    const {columns} = this.options\n    return {\n      ...this.__infoDataSet(),\n      error: this.state.error,\n      header: columns === true,\n      index: this.state.record.length,\n    }\n  }\n  __infoField(){\n    const {columns} = this.options\n    const isColumns = Array.isArray(columns)\n    return {\n      ...this.__infoRecord(),\n      column: isColumns === true ?\n        ( columns.length > this.state.record.length ?\n          columns[this.state.record.length].name :\n          null\n        ) :\n        this.state.record.length,\n      quoting: this.state.wasQuoting,\n    }\n  }\n}\n\nconst parse = function(){\n  let data, options, callback\n  for(let i in arguments){\n    const argument = arguments[i]\n    const type = typeof argument\n    if(data === undefined && (typeof argument === 'string' || Buffer.isBuffer(argument))){\n      data = argument\n    }else if(options === undefined && isObject(argument)){\n      options = argument\n    }else if(callback === undefined && type === 'function'){\n      callback = argument\n    }else{\n      throw new CsvError('CSV_INVALID_ARGUMENT', [\n        'Invalid argument:',\n        `got ${JSON.stringify(argument)} at index ${i}`\n      ], options || {})\n    }\n  }\n  const parser = new Parser(options)\n  if(callback){\n    const records = options === undefined || options.objname === undefined ? [] : {}\n    parser.on('readable', function(){\n      let record\n      while((record = this.read()) !== null){\n        if(options === undefined || options.objname === undefined){\n          records.push(record)\n        }else{\n          records[record[0]] = record[1]\n        }\n      }\n    })\n    parser.on('error', function(err){\n      callback(err, undefined, parser.__infoDataSet())\n    })\n    parser.on('end', function(){\n      callback(undefined, records, parser.__infoDataSet())\n    })\n  }\n  if(data !== undefined){\n    // Give a chance for events to be registered later\n    if(typeof setImmediate === 'function'){\n      setImmediate(function(){\n        parser.write(data)\n        parser.end()\n      })\n    }else{\n      parser.write(data)\n      parser.end()\n    }\n  }\n  return parser\n}\n\nclass CsvError extends Error {\n  constructor(code, message, options, ...contexts) {\n    if(Array.isArray(message)) message = message.join(' ')\n    super(message)\n    if(Error.captureStackTrace !== undefined){\n      Error.captureStackTrace(this, CsvError)\n    }\n    this.code = code\n    for(const context of contexts){\n      for(const key in context){\n        const value = context[key]\n        this[key] = Buffer.isBuffer(value) ? value.toString(options.encoding) : value == null ? value : JSON.parse(JSON.stringify(value))\n      }\n    }\n  }\n}\n\nparse.Parser = Parser\n\nparse.CsvError = CsvError\n\nmodule.exports = parse\n\nconst underscore = function(str){\n  return str.replace(/([A-Z])/g, function(_, match){\n    return '_' + match.toLowerCase()\n  })\n}\n\nconst isObject = function(obj){\n  return (typeof obj === 'object' && obj !== null && !Array.isArray(obj))\n}\n\nconst isRecordEmpty = function(record){\n  return record.every( (field) => field == null || field.toString && field.toString().trim() === '' )\n}\n\nconst normalizeColumnsArray = function(columns){\n  const normalizedColumns = [];\n  for(let i = 0, l = columns.length; i < l; i++){\n    const column = columns[i]\n    if(column === undefined || column === null || column === false){\n      normalizedColumns[i] = { disabled: true }\n    }else if(typeof column === 'string'){\n      normalizedColumns[i] = { name: column }\n    }else if(isObject(column)){\n      if(typeof column.name !== 'string'){\n        throw new CsvError('CSV_OPTION_COLUMNS_MISSING_NAME', [\n          'Option columns missing name:',\n          `property \"name\" is required at position ${i}`,\n          'when column is an object literal'\n        ])\n      }\n      normalizedColumns[i] = column\n    }else{\n      throw new CsvError('CSV_INVALID_COLUMN_DEFINITION', [\n        'Invalid column definition:',\n        'expect a string or a literal object,',\n        `got ${JSON.stringify(column)} at position ${i}`\n      ])\n    }\n  }\n  return normalizedColumns;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}