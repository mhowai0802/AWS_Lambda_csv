{"ast":null,"code":"/*\nCSV Stringify\n\nPlease look at the [project documentation](https://csv.js.org/stringify/) for\nadditional information.\n*/\nconst {\n  Transform\n} = require('stream');\n\nconst bom_utf8 = Buffer.from([239, 187, 191]);\n\nclass Stringifier extends Transform {\n  constructor() {\n    let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    super({ ...{\n        writableObjectMode: true\n      },\n      ...opts\n    });\n    const options = {};\n    let err; // Merge with user options\n\n    for (let opt in opts) {\n      options[underscore(opt)] = opts[opt];\n    }\n\n    if (err = this.normalize(options)) throw err;\n\n    switch (options.record_delimiter) {\n      case 'auto':\n        options.record_delimiter = null;\n        break;\n\n      case 'unix':\n        options.record_delimiter = \"\\n\";\n        break;\n\n      case 'mac':\n        options.record_delimiter = \"\\r\";\n        break;\n\n      case 'windows':\n        options.record_delimiter = \"\\r\\n\";\n        break;\n\n      case 'ascii':\n        options.record_delimiter = \"\\u001e\";\n        break;\n\n      case 'unicode':\n        options.record_delimiter = \"\\u2028\";\n        break;\n    } // Expose options\n\n\n    this.options = options; // Internal state\n\n    this.state = {\n      stop: false\n    }; // Information\n\n    this.info = {\n      records: 0\n    };\n  }\n\n  normalize(options) {\n    // Normalize option `bom`\n    if (options.bom === undefined || options.bom === null || options.bom === false) {\n      options.bom = false;\n    } else if (options.bom !== true) {\n      return new CsvError('CSV_OPTION_BOOLEAN_INVALID_TYPE', ['option `bom` is optional and must be a boolean value,', `got ${JSON.stringify(options.bom)}`]);\n    } // Normalize option `delimiter`\n\n\n    if (options.delimiter === undefined || options.delimiter === null) {\n      options.delimiter = ',';\n    } else if (Buffer.isBuffer(options.delimiter)) {\n      options.delimiter = options.delimiter.toString();\n    } else if (typeof options.delimiter !== 'string') {\n      return new CsvError('CSV_OPTION_DELIMITER_INVALID_TYPE', ['option `delimiter` must be a buffer or a string,', `got ${JSON.stringify(options.delimiter)}`]);\n    } // Normalize option `quote`\n\n\n    if (options.quote === undefined || options.quote === null) {\n      options.quote = '\"';\n    } else if (options.quote === true) {\n      options.quote = '\"';\n    } else if (options.quote === false) {\n      options.quote = '';\n    } else if (Buffer.isBuffer(options.quote)) {\n      options.quote = options.quote.toString();\n    } else if (typeof options.quote !== 'string') {\n      return new CsvError('CSV_OPTION_QUOTE_INVALID_TYPE', ['option `quote` must be a boolean, a buffer or a string,', `got ${JSON.stringify(options.quote)}`]);\n    } // Normalize option `quoted`\n\n\n    if (options.quoted === undefined || options.quoted === null) {\n      options.quoted = false;\n    } else {// todo\n    } // Normalize option `quoted_empty`\n\n\n    if (options.quoted_empty === undefined || options.quoted_empty === null) {\n      options.quoted_empty = undefined;\n    } else {// todo\n    } // Normalize option `quoted_match`\n\n\n    if (options.quoted_match === undefined || options.quoted_match === null || options.quoted_match === false) {\n      options.quoted_match = null;\n    } else if (!Array.isArray(options.quoted_match)) {\n      options.quoted_match = [options.quoted_match];\n    }\n\n    if (options.quoted_match) {\n      for (let quoted_match of options.quoted_match) {\n        const isString = typeof quoted_match === 'string';\n        const isRegExp = quoted_match instanceof RegExp;\n\n        if (!isString && !isRegExp) {\n          return Error(`Invalid Option: quoted_match must be a string or a regex, got ${JSON.stringify(quoted_match)}`);\n        }\n      }\n    } // Normalize option `quoted_string`\n\n\n    if (options.quoted_string === undefined || options.quoted_string === null) {\n      options.quoted_string = false;\n    } else {// todo\n    } // Normalize option `eof`\n\n\n    if (options.eof === undefined || options.eof === null) {\n      options.eof = true;\n    } else {// todo\n    } // Normalize option `escape`\n\n\n    if (options.escape === undefined || options.escape === null) {\n      options.escape = '\"';\n    } else if (Buffer.isBuffer(options.escape)) {\n      options.escape = options.escape.toString();\n    } else if (typeof options.escape !== 'string') {\n      return Error(`Invalid Option: escape must be a buffer or a string, got ${JSON.stringify(options.escape)}`);\n    }\n\n    if (options.escape.length > 1) {\n      return Error(`Invalid Option: escape must be one character, got ${options.escape.length} characters`);\n    } // Normalize option `header`\n\n\n    if (options.header === undefined || options.header === null) {\n      options.header = false;\n    } else {// todo\n    } // Normalize option `columns`\n\n\n    options.columns = this.normalize_columns(options.columns); // Normalize option `quoted`\n\n    if (options.quoted === undefined || options.quoted === null) {\n      options.quoted = false;\n    } else {// todo\n    } // Normalize option `cast`\n\n\n    if (options.cast === undefined || options.cast === null) {\n      options.cast = {};\n    } else {// todo\n    } // Normalize option cast.bigint\n\n\n    if (options.cast.bigint === undefined || options.cast.bigint === null) {\n      // Cast boolean to string by default\n      options.cast.bigint = value => '' + value;\n    } // Normalize option cast.boolean\n\n\n    if (options.cast.boolean === undefined || options.cast.boolean === null) {\n      // Cast boolean to string by default\n      options.cast.boolean = value => value ? '1' : '';\n    } // Normalize option cast.date\n\n\n    if (options.cast.date === undefined || options.cast.date === null) {\n      // Cast date to timestamp string by default\n      options.cast.date = value => '' + value.getTime();\n    } // Normalize option cast.number\n\n\n    if (options.cast.number === undefined || options.cast.number === null) {\n      // Cast number to string using native casting by default\n      options.cast.number = value => '' + value;\n    } // Normalize option cast.object\n\n\n    if (options.cast.object === undefined || options.cast.object === null) {\n      // Stringify object as JSON by default\n      options.cast.object = value => JSON.stringify(value);\n    } // Normalize option cast.string\n\n\n    if (options.cast.string === undefined || options.cast.string === null) {\n      // Leave string untouched\n      options.cast.string = function (value) {\n        return value;\n      };\n    } // Normalize option `record_delimiter`\n\n\n    if (options.record_delimiter === undefined || options.record_delimiter === null) {\n      options.record_delimiter = '\\n';\n    } else if (Buffer.isBuffer(options.record_delimiter)) {\n      options.record_delimiter = options.record_delimiter.toString();\n    } else if (typeof options.record_delimiter !== 'string') {\n      return Error(`Invalid Option: record_delimiter must be a buffer or a string, got ${JSON.stringify(options.record_delimiter)}`);\n    }\n  }\n\n  _transform(chunk, encoding, callback) {\n    if (this.state.stop === true) {\n      return;\n    } // Chunk validation\n\n\n    if (!Array.isArray(chunk) && typeof chunk !== 'object') {\n      this.state.stop = true;\n      return callback(Error(`Invalid Record: expect an array or an object, got ${JSON.stringify(chunk)}`));\n    } // Detect columns from the first record\n\n\n    if (this.info.records === 0) {\n      if (Array.isArray(chunk)) {\n        if (this.options.header === true && !this.options.columns) {\n          this.state.stop = true;\n          return callback(Error('Undiscoverable Columns: header option requires column option or object records'));\n        }\n      } else if (this.options.columns === undefined || this.options.columns === null) {\n        this.options.columns = this.normalize_columns(Object.keys(chunk));\n      }\n    } // Emit the header\n\n\n    if (this.info.records === 0) {\n      this.bom();\n      this.headers();\n    } // Emit and stringify the record if an object or an array\n\n\n    try {\n      this.emit('record', chunk, this.info.records);\n    } catch (err) {\n      this.state.stop = true;\n      return this.emit('error', err);\n    } // Convert the record into a string\n\n\n    let chunk_string;\n\n    if (this.options.eof) {\n      chunk_string = this.stringify(chunk);\n\n      if (chunk_string === undefined) {\n        return;\n      } else {\n        chunk_string = chunk_string + this.options.record_delimiter;\n      }\n    } else {\n      chunk_string = this.stringify(chunk);\n\n      if (chunk_string === undefined) {\n        return;\n      } else {\n        if (this.options.header || this.info.records) {\n          chunk_string = this.options.record_delimiter + chunk_string;\n        }\n      }\n    } // Emit the csv\n\n\n    this.info.records++;\n    this.push(chunk_string);\n    callback();\n  }\n\n  _flush(callback) {\n    if (this.info.records === 0) {\n      this.bom();\n      this.headers();\n    }\n\n    callback();\n  }\n\n  stringify(chunk) {\n    let chunkIsHeader = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n    if (typeof chunk !== 'object') {\n      return chunk;\n    }\n\n    const {\n      columns,\n      header\n    } = this.options;\n    const record = []; // Record is an array\n\n    if (Array.isArray(chunk)) {\n      // We are getting an array but the user has specified output columns. In\n      // this case, we respect the columns indexes\n      if (columns) {\n        chunk.splice(columns.length);\n      } // Cast record elements\n\n\n      for (let i = 0; i < chunk.length; i++) {\n        const field = chunk[i];\n\n        const [err, value] = this.__cast(field, {\n          index: i,\n          column: i,\n          records: this.info.records,\n          header: chunkIsHeader\n        });\n\n        if (err) {\n          this.emit('error', err);\n          return;\n        }\n\n        record[i] = [value, field];\n      } // Record is a literal object\n\n    } else {\n      if (columns) {\n        for (let i = 0; i < columns.length; i++) {\n          const field = get(chunk, columns[i].key);\n\n          const [err, value] = this.__cast(field, {\n            index: i,\n            column: columns[i].key,\n            records: this.info.records,\n            header: chunkIsHeader\n          });\n\n          if (err) {\n            this.emit('error', err);\n            return;\n          }\n\n          record[i] = [value, field];\n        }\n      } else {\n        for (let column of chunk) {\n          const field = chunk[column];\n\n          const [err, value] = this.__cast(field, {\n            index: i,\n            column: columns[i].key,\n            records: this.info.records,\n            header: chunkIsHeader\n          });\n\n          if (err) {\n            this.emit('error', err);\n            return;\n          }\n\n          record.push([value, field]);\n        }\n      }\n    }\n\n    let csvrecord = '';\n\n    for (let i = 0; i < record.length; i++) {\n      let options, err;\n      let [value, field] = record[i];\n\n      if (typeof value === \"string\") {\n        options = this.options;\n      } else if (isObject(value)) {\n        // let { value, ...options } = value\n        options = value;\n        value = options.value;\n        delete options.value;\n\n        if (typeof value !== \"string\" && value !== undefined && value !== null) {\n          this.emit(\"error\", Error(`Invalid Casting Value: returned value must return a string, null or undefined, got ${JSON.stringify(value)}`));\n          return;\n        }\n\n        options = { ...this.options,\n          ...options\n        };\n\n        if (err = this.normalize(options)) {\n          this.emit(\"error\", err);\n          return;\n        }\n      } else if (value === undefined || value === null) {\n        options = this.options;\n      } else {\n        this.emit(\"error\", Error(`Invalid Casting Value: returned value must return a string, an object, null or undefined, got ${JSON.stringify(value)}`));\n        return;\n      }\n\n      const {\n        delimiter,\n        escape,\n        quote,\n        quoted,\n        quoted_empty,\n        quoted_string,\n        quoted_match,\n        record_delimiter\n      } = options;\n\n      if (value) {\n        if (typeof value !== 'string') {\n          this.emit(\"error\", Error(`Formatter must return a string, null or undefined, got ${JSON.stringify(value)}`));\n          return null;\n        }\n\n        const containsdelimiter = delimiter.length && value.indexOf(delimiter) >= 0;\n        const containsQuote = quote !== '' && value.indexOf(quote) >= 0;\n        const containsEscape = value.indexOf(escape) >= 0 && escape !== quote;\n        const containsRecordDelimiter = value.indexOf(record_delimiter) >= 0;\n        const quotedString = quoted_string && typeof field === 'string';\n        let quotedMatch = quoted_match && quoted_match.filter(quoted_match => {\n          if (typeof quoted_match === 'string') {\n            return value.indexOf(quoted_match) !== -1;\n          } else {\n            return quoted_match.test(value);\n          }\n        });\n        quotedMatch = quotedMatch && quotedMatch.length > 0;\n        const shouldQuote = containsQuote === true || containsdelimiter || containsRecordDelimiter || quoted || quotedString || quotedMatch;\n\n        if (shouldQuote === true && containsEscape === true) {\n          const regexp = escape === '\\\\' ? new RegExp(escape + escape, 'g') : new RegExp(escape, 'g');\n          value = value.replace(regexp, escape + escape);\n        }\n\n        if (containsQuote === true) {\n          const regexp = new RegExp(quote, 'g');\n          value = value.replace(regexp, escape + quote);\n        }\n\n        if (shouldQuote === true) {\n          value = quote + value + quote;\n        }\n\n        csvrecord += value;\n      } else if (quoted_empty === true || field === '' && quoted_string === true && quoted_empty !== false) {\n        csvrecord += quote + quote;\n      }\n\n      if (i !== record.length - 1) {\n        csvrecord += delimiter;\n      }\n    }\n\n    return csvrecord;\n  }\n\n  bom() {\n    if (this.options.bom !== true) {\n      return;\n    }\n\n    this.push(bom_utf8);\n  }\n\n  headers() {\n    if (this.options.header === false) {\n      return;\n    }\n\n    if (this.options.columns === undefined) {\n      return;\n    }\n\n    let headers = this.options.columns.map(column => column.header);\n\n    if (this.options.eof) {\n      headers = this.stringify(headers, true) + this.options.record_delimiter;\n    } else {\n      headers = this.stringify(headers);\n    }\n\n    this.push(headers);\n  }\n\n  __cast(value, context) {\n    const type = typeof value;\n\n    try {\n      if (type === 'string') {\n        // Fine for 99% of the cases\n        return [undefined, this.options.cast.string(value, context)];\n      } else if (type === 'bigint') {\n        return [undefined, this.options.cast.bigint(value, context)];\n      } else if (type === 'number') {\n        return [undefined, this.options.cast.number(value, context)];\n      } else if (type === 'boolean') {\n        return [undefined, this.options.cast.boolean(value, context)];\n      } else if (value instanceof Date) {\n        return [undefined, this.options.cast.date(value, context)];\n      } else if (type === 'object' && value !== null) {\n        return [undefined, this.options.cast.object(value, context)];\n      } else {\n        return [undefined, value, value];\n      }\n    } catch (err) {\n      return [err];\n    }\n  }\n\n  normalize_columns(columns) {\n    if (columns === undefined || columns === null) {\n      return undefined;\n    }\n\n    if (typeof columns !== 'object') {\n      throw Error('Invalid option \"columns\": expect an array or an object');\n    }\n\n    if (!Array.isArray(columns)) {\n      const newcolumns = [];\n\n      for (let k in columns) {\n        newcolumns.push({\n          key: k,\n          header: columns[k]\n        });\n      }\n\n      columns = newcolumns;\n    } else {\n      const newcolumns = [];\n\n      for (let column of columns) {\n        if (typeof column === 'string') {\n          newcolumns.push({\n            key: column,\n            header: column\n          });\n        } else if (typeof column === 'object' && column !== undefined && !Array.isArray(column)) {\n          if (!column.key) {\n            throw Error('Invalid column definition: property \"key\" is required');\n          }\n\n          if (column.header === undefined) {\n            column.header = column.key;\n          }\n\n          newcolumns.push(column);\n        } else {\n          throw Error('Invalid column definition: expect a string or an object');\n        }\n      }\n\n      columns = newcolumns;\n    }\n\n    return columns;\n  }\n\n}\n\nconst stringify = function () {\n  let data, options, callback;\n\n  for (let i in arguments) {\n    const argument = arguments[i];\n    const type = typeof argument;\n\n    if (data === undefined && Array.isArray(argument)) {\n      data = argument;\n    } else if (options === undefined && isObject(argument)) {\n      options = argument;\n    } else if (callback === undefined && type === 'function') {\n      callback = argument;\n    } else {\n      throw new CsvError('CSV_INVALID_ARGUMENT', ['Invalid argument:', `got ${JSON.stringify(argument)} at index ${i}`]);\n    }\n  }\n\n  const stringifier = new Stringifier(options);\n\n  if (callback) {\n    const chunks = [];\n    stringifier.on('readable', function () {\n      let chunk;\n\n      while ((chunk = this.read()) !== null) {\n        chunks.push(chunk);\n      }\n    });\n    stringifier.on('error', function (err) {\n      callback(err);\n    });\n    stringifier.on('end', function () {\n      callback(undefined, chunks.join(''));\n    });\n  }\n\n  if (data !== undefined) {\n    // Give a chance for events to be registered later\n    if (typeof setImmediate === 'function') {\n      setImmediate(function () {\n        for (let record of data) {\n          stringifier.write(record);\n        }\n\n        stringifier.end();\n      });\n    } else {\n      for (let record of data) {\n        stringifier.write(record);\n      }\n\n      stringifier.end();\n    }\n  }\n\n  return stringifier;\n};\n\nclass CsvError extends Error {\n  constructor(code, message) {\n    if (Array.isArray(message)) message = message.join(' ');\n    super(message);\n\n    if (Error.captureStackTrace !== undefined) {\n      Error.captureStackTrace(this, CsvError);\n    }\n\n    this.code = code;\n\n    for (var _len = arguments.length, contexts = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n      contexts[_key - 2] = arguments[_key];\n    }\n\n    for (const context of contexts) {\n      for (const key in context) {\n        const value = context[key];\n        this[key] = Buffer.isBuffer(value) ? value.toString() : value == null ? value : JSON.parse(JSON.stringify(value));\n      }\n    }\n  }\n\n}\n\nstringify.Stringifier = Stringifier;\nstringify.CsvError = CsvError;\nmodule.exports = stringify;\n\nconst isObject = function (obj) {\n  return typeof obj === 'object' && obj !== null && !Array.isArray(obj);\n};\n\nconst underscore = function (str) {\n  return str.replace(/([A-Z])/g, function (_, match) {\n    return '_' + match.toLowerCase();\n  });\n}; // Lodash implementation of `get`\n\n\nconst charCodeOfDot = '.'.charCodeAt(0);\nconst reEscapeChar = /\\\\(\\\\)?/g;\nconst rePropName = RegExp( // Match anything that isn't a dot or bracket.\n'[^.[\\\\]]+' + '|' + // Or match property names within brackets.\n'\\\\[(?:' + // Match a non-string expression.\n'([^\"\\'][^[]*)' + '|' + // Or match strings (supports escaping characters).\n'([\"\\'])((?:(?!\\\\2)[^\\\\\\\\]|\\\\\\\\.)*?)\\\\2' + ')\\\\]' + '|' + // Or match \"\" as the space between consecutive dots or empty brackets.\n'(?=(?:\\\\.|\\\\[\\\\])(?:\\\\.|\\\\[\\\\]|$))', 'g');\nconst reIsDeepProp = /\\.|\\[(?:[^[\\]]*|([\"'])(?:(?!\\1)[^\\\\]|\\\\.)*?\\1)\\]/;\nconst reIsPlainProp = /^\\w*$/;\n\nconst getTag = function (value) {\n  if (!value) value === undefined ? '[object Undefined]' : '[object Null]';\n  return Object.prototype.toString.call(value);\n};\n\nconst isKey = function (value, object) {\n  if (Array.isArray(value)) {\n    return false;\n  }\n\n  const type = typeof value;\n\n  if (type === 'number' || type === 'symbol' || type === 'boolean' || !value || isSymbol(value)) {\n    return true;\n  }\n\n  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);\n};\n\nconst isSymbol = function (value) {\n  const type = typeof value;\n  return type === 'symbol' || type === 'object' && value && getTag(value) === '[object Symbol]';\n};\n\nconst stringToPath = function (string) {\n  const result = [];\n\n  if (string.charCodeAt(0) === charCodeOfDot) {\n    result.push('');\n  }\n\n  string.replace(rePropName, function (match, expression, quote, subString) {\n    let key = match;\n\n    if (quote) {\n      key = subString.replace(reEscapeChar, '$1');\n    } else if (expression) {\n      key = expression.trim();\n    }\n\n    result.push(key);\n  });\n  return result;\n};\n\nconst castPath = function (value, object) {\n  if (Array.isArray(value)) {\n    return value;\n  } else {\n    return isKey(value, object) ? [value] : stringToPath(value);\n  }\n};\n\nconst toKey = function (value) {\n  if (typeof value === 'string' || isSymbol(value)) return value;\n  const result = `${value}`;\n  return result == '0' && 1 / value == -INFINITY ? '-0' : result;\n};\n\nconst get = function (object, path) {\n  path = castPath(path, object);\n  let index = 0;\n  const length = path.length;\n\n  while (object != null && index < length) {\n    object = object[toKey(path[index++])];\n  }\n\n  return index && index === length ? object : undefined;\n};","map":{"version":3,"names":["Transform","require","bom_utf8","Buffer","from","Stringifier","constructor","opts","writableObjectMode","options","err","opt","underscore","normalize","record_delimiter","state","stop","info","records","bom","undefined","CsvError","JSON","stringify","delimiter","isBuffer","toString","quote","quoted","quoted_empty","quoted_match","Array","isArray","isString","isRegExp","RegExp","Error","quoted_string","eof","escape","length","header","columns","normalize_columns","cast","bigint","value","boolean","date","getTime","number","object","string","_transform","chunk","encoding","callback","Object","keys","headers","emit","chunk_string","push","_flush","chunkIsHeader","record","splice","i","field","__cast","index","column","get","key","csvrecord","isObject","containsdelimiter","indexOf","containsQuote","containsEscape","containsRecordDelimiter","quotedString","quotedMatch","filter","test","shouldQuote","regexp","replace","map","context","type","Date","newcolumns","k","data","arguments","argument","stringifier","chunks","on","read","join","setImmediate","write","end","code","message","captureStackTrace","contexts","parse","module","exports","obj","str","_","match","toLowerCase","charCodeOfDot","charCodeAt","reEscapeChar","rePropName","reIsDeepProp","reIsPlainProp","getTag","prototype","call","isKey","isSymbol","stringToPath","result","expression","subString","trim","castPath","toKey","INFINITY","path"],"sources":["/Users/waiwai/Desktop/Github/Einstein/testing/node_modules/csv-stringify/lib/index.js"],"sourcesContent":["\n/*\nCSV Stringify\n\nPlease look at the [project documentation](https://csv.js.org/stringify/) for\nadditional information.\n*/\n\nconst { Transform } = require('stream')\nconst bom_utf8 = Buffer.from([239, 187, 191])\n\nclass Stringifier extends Transform {\n  constructor(opts = {}){\n    super({...{writableObjectMode: true}, ...opts})\n    const options = {}\n    let err\n    // Merge with user options\n    for(let opt in opts){\n      options[underscore(opt)] = opts[opt]\n    }\n    if(err = this.normalize(options)) throw err\n    switch(options.record_delimiter){\n      case 'auto':\n        options.record_delimiter = null\n        break\n      case 'unix':\n        options.record_delimiter = \"\\n\"\n        break\n      case 'mac':\n        options.record_delimiter = \"\\r\"\n        break\n      case 'windows':\n        options.record_delimiter = \"\\r\\n\"\n        break\n      case 'ascii':\n        options.record_delimiter = \"\\u001e\"\n        break\n      case 'unicode':\n        options.record_delimiter = \"\\u2028\"\n        break\n    }\n    // Expose options\n    this.options = options\n    // Internal state\n    this.state = {\n      stop: false\n    }\n    // Information\n    this.info = {\n      records: 0\n    }\n  }\n  normalize(options){\n    // Normalize option `bom`\n    if(options.bom === undefined || options.bom === null || options.bom === false){\n      options.bom = false\n    }else if(options.bom !== true){\n      return new CsvError('CSV_OPTION_BOOLEAN_INVALID_TYPE', [\n        'option `bom` is optional and must be a boolean value,',\n        `got ${JSON.stringify(options.bom)}`\n      ])\n    }\n    // Normalize option `delimiter`\n    if(options.delimiter === undefined || options.delimiter === null){\n      options.delimiter = ','\n    }else if(Buffer.isBuffer(options.delimiter)){\n      options.delimiter = options.delimiter.toString()\n    }else if(typeof options.delimiter !== 'string'){\n      return new CsvError('CSV_OPTION_DELIMITER_INVALID_TYPE', [\n        'option `delimiter` must be a buffer or a string,',\n        `got ${JSON.stringify(options.delimiter)}`\n      ])\n    }\n    // Normalize option `quote`\n    if(options.quote === undefined || options.quote === null){\n      options.quote = '\"'\n    }else if(options.quote === true){\n      options.quote = '\"'\n    }else if(options.quote === false){\n      options.quote = ''\n    }else if (Buffer.isBuffer(options.quote)){\n      options.quote = options.quote.toString()\n    }else if(typeof options.quote !== 'string'){\n      return new CsvError('CSV_OPTION_QUOTE_INVALID_TYPE', [\n        'option `quote` must be a boolean, a buffer or a string,',\n        `got ${JSON.stringify(options.quote)}`\n      ])\n    }\n    // Normalize option `quoted`\n    if(options.quoted === undefined || options.quoted === null){\n      options.quoted = false\n    }else{\n      // todo\n    }\n    // Normalize option `quoted_empty`\n    if(options.quoted_empty === undefined || options.quoted_empty === null){\n      options.quoted_empty = undefined\n    }else{\n      // todo\n    }\n    // Normalize option `quoted_match`\n    if(options.quoted_match === undefined || options.quoted_match === null || options.quoted_match === false){\n      options.quoted_match = null\n    }else if(!Array.isArray(options.quoted_match)){\n      options.quoted_match = [options.quoted_match]\n    }\n    if(options.quoted_match){\n      for(let quoted_match of options.quoted_match){\n        const isString = typeof quoted_match === 'string'\n        const isRegExp = quoted_match instanceof RegExp\n        if(!isString && !isRegExp){\n          return Error(`Invalid Option: quoted_match must be a string or a regex, got ${JSON.stringify(quoted_match)}`)\n        }\n      }\n    }\n    // Normalize option `quoted_string`\n    if(options.quoted_string === undefined || options.quoted_string === null){\n      options.quoted_string = false\n    }else{\n      // todo\n    }\n    // Normalize option `eof`\n    if(options.eof === undefined || options.eof === null){\n      options.eof = true\n    }else{\n      // todo\n    }\n    // Normalize option `escape`\n    if(options.escape === undefined || options.escape === null){\n      options.escape = '\"'\n    }else if(Buffer.isBuffer(options.escape)){\n      options.escape = options.escape.toString()\n    }else if(typeof options.escape !== 'string'){\n      return Error(`Invalid Option: escape must be a buffer or a string, got ${JSON.stringify(options.escape)}`)\n    }\n    if (options.escape.length > 1){\n      return Error(`Invalid Option: escape must be one character, got ${options.escape.length} characters`)\n    }\n    // Normalize option `header`\n    if(options.header === undefined || options.header === null){\n      options.header = false\n    }else{\n      // todo\n    }\n    // Normalize option `columns`\n    options.columns = this.normalize_columns(options.columns)\n    // Normalize option `quoted`\n    if(options.quoted === undefined || options.quoted === null){\n      options.quoted = false\n    }else{\n      // todo\n    }\n    // Normalize option `cast`\n    if(options.cast === undefined || options.cast === null){\n      options.cast = {}\n    }else{\n      // todo\n    }\n    // Normalize option cast.bigint\n    if(options.cast.bigint === undefined || options.cast.bigint === null){\n      // Cast boolean to string by default\n      options.cast.bigint = value => '' + value\n    }\n    // Normalize option cast.boolean\n    if(options.cast.boolean === undefined || options.cast.boolean === null){\n      // Cast boolean to string by default\n      options.cast.boolean = value => value ? '1' : ''\n    }\n    // Normalize option cast.date\n    if(options.cast.date === undefined || options.cast.date === null){\n      // Cast date to timestamp string by default\n      options.cast.date = value => '' + value.getTime()\n    }\n    // Normalize option cast.number\n    if(options.cast.number === undefined || options.cast.number === null){\n      // Cast number to string using native casting by default\n      options.cast.number = value => '' + value\n    }\n    // Normalize option cast.object\n    if(options.cast.object === undefined || options.cast.object === null){\n      // Stringify object as JSON by default\n      options.cast.object = value => JSON.stringify(value)\n    }\n    // Normalize option cast.string\n    if(options.cast.string === undefined || options.cast.string === null){\n      // Leave string untouched\n      options.cast.string = function(value){return value}\n    }\n    // Normalize option `record_delimiter`\n    if(options.record_delimiter === undefined || options.record_delimiter === null){\n      options.record_delimiter = '\\n'\n    }else if(Buffer.isBuffer(options.record_delimiter)){\n      options.record_delimiter = options.record_delimiter.toString()\n    }else if(typeof options.record_delimiter !== 'string'){\n      return Error(`Invalid Option: record_delimiter must be a buffer or a string, got ${JSON.stringify(options.record_delimiter)}`)\n    }\n  }\n  _transform(chunk, encoding, callback){\n    if(this.state.stop === true){\n      return\n    }\n    // Chunk validation\n    if(!Array.isArray(chunk) && typeof chunk !== 'object'){\n      this.state.stop = true\n      return callback(Error(`Invalid Record: expect an array or an object, got ${JSON.stringify(chunk)}`))\n    }\n    // Detect columns from the first record\n    if(this.info.records === 0){\n      if(Array.isArray(chunk)){\n        if(this.options.header === true && !this.options.columns){\n          this.state.stop = true\n          return callback(Error('Undiscoverable Columns: header option requires column option or object records'))\n        }\n      }else if(this.options.columns === undefined || this.options.columns === null){\n        this.options.columns = this.normalize_columns(Object.keys(chunk))\n      }\n    }\n    // Emit the header\n    if(this.info.records === 0){\n      this.bom()\n      this.headers()\n    }\n    // Emit and stringify the record if an object or an array\n    try{\n      this.emit('record', chunk, this.info.records)\n    }catch(err){\n      this.state.stop = true\n      return this.emit('error', err)\n    }\n    // Convert the record into a string\n    let chunk_string\n    if(this.options.eof){\n      chunk_string = this.stringify(chunk)\n      if(chunk_string === undefined){\n        return\n      }else{\n        chunk_string = chunk_string + this.options.record_delimiter\n      }\n    }else{\n      chunk_string = this.stringify(chunk)\n      if(chunk_string === undefined){\n        return\n      }else{\n        if(this.options.header || this.info.records){\n          chunk_string = this.options.record_delimiter + chunk_string\n        }\n      }\n    }\n    // Emit the csv\n    this.info.records++\n    this.push(chunk_string)\n    callback()\n  }\n  _flush(callback){\n    if(this.info.records === 0){\n      this.bom()\n      this.headers()\n    }\n    callback()\n  }\n  stringify(chunk, chunkIsHeader=false){\n    if(typeof chunk !== 'object'){\n      return chunk\n    }\n    const {columns, header} = this.options\n    const record = []\n    // Record is an array\n    if(Array.isArray(chunk)){\n      // We are getting an array but the user has specified output columns. In\n      // this case, we respect the columns indexes\n      if(columns){\n        chunk.splice(columns.length)\n      }\n      // Cast record elements\n      for(let i=0; i<chunk.length; i++){\n        const field = chunk[i]\n        const [err, value] = this.__cast(field, {\n          index: i, column: i, records: this.info.records, header: chunkIsHeader\n        })\n        if(err){\n          this.emit('error', err)\n          return\n        }\n        record[i] = [value, field]\n      }\n    // Record is a literal object\n    }else{\n      if(columns){\n        for(let i=0; i<columns.length; i++){\n          const field = get(chunk, columns[i].key)\n          const [err, value] = this.__cast(field, {\n            index: i, column: columns[i].key, records: this.info.records, header: chunkIsHeader\n          })\n          if(err){\n            this.emit('error', err)\n            return\n          }\n          record[i] = [value, field]\n        }\n      }else{\n        for(let column of chunk){\n          const field = chunk[column]\n          const [err, value] = this.__cast(field, {\n            index: i, column: columns[i].key, records: this.info.records, header: chunkIsHeader\n          })\n          if(err){\n            this.emit('error', err)\n            return\n          }\n          record.push([value, field])\n        }\n      }\n    }\n    let csvrecord = ''\n    for(let i=0; i<record.length; i++){\n      let options, err\n      let [value, field] = record[i]\n      if(typeof value === \"string\"){\n        options = this.options\n      }else if(isObject(value)){\n        // let { value, ...options } = value\n        options = value\n        value = options.value\n        delete options.value\n        if(typeof value !== \"string\" && value !== undefined && value !== null){\n          this.emit(\"error\", Error(`Invalid Casting Value: returned value must return a string, null or undefined, got ${JSON.stringify(value)}`))\n          return\n        }\n        options = {...this.options, ...options}\n        if(err = this.normalize(options)){\n          this.emit(\"error\", err)\n          return\n        }\n      }else if(value === undefined || value === null){\n        options = this.options\n      }else{\n        this.emit(\"error\", Error(`Invalid Casting Value: returned value must return a string, an object, null or undefined, got ${JSON.stringify(value)}`))\n        return\n      }\n      const {delimiter, escape, quote, quoted, quoted_empty, quoted_string, quoted_match, record_delimiter} = options\n      if(value){\n        if(typeof value !== 'string'){\n          this.emit(\"error\", Error(`Formatter must return a string, null or undefined, got ${JSON.stringify(value)}`))\n          return null\n        }\n        const containsdelimiter = delimiter.length && value.indexOf(delimiter) >= 0\n        const containsQuote = (quote !== '') && value.indexOf(quote) >= 0\n        const containsEscape = value.indexOf(escape) >= 0 && (escape !== quote)\n        const containsRecordDelimiter = value.indexOf(record_delimiter) >= 0\n        const quotedString = quoted_string && typeof field === 'string'\n        let quotedMatch = quoted_match && quoted_match.filter( quoted_match => {\n          if(typeof quoted_match === 'string'){\n            return value.indexOf(quoted_match) !== -1\n          }else{\n            return quoted_match.test(value)\n          }\n        })\n        quotedMatch = quotedMatch && quotedMatch.length > 0\n        const shouldQuote = containsQuote === true || containsdelimiter || containsRecordDelimiter || quoted || quotedString || quotedMatch\n        if(shouldQuote === true && containsEscape === true){\n          const regexp = escape === '\\\\'\n          ? new RegExp(escape + escape, 'g')\n          : new RegExp(escape, 'g')\n          value = value.replace(regexp, escape + escape)\n        }\n        if(containsQuote === true){\n          const regexp = new RegExp(quote,'g')\n          value = value.replace(regexp, escape + quote)\n        }\n        if(shouldQuote === true){\n          value = quote + value + quote\n        }\n        csvrecord += value\n      }else if(quoted_empty === true || (field === '' && quoted_string === true && quoted_empty !== false)){\n        csvrecord += quote + quote\n      }\n      if(i !== record.length - 1){\n        csvrecord += delimiter\n      }\n    }\n    return csvrecord\n  }\n  bom(){\n    if(this.options.bom !== true){\n      return\n    }\n    this.push(bom_utf8)\n  }\n  headers(){\n    if(this.options.header === false){\n      return\n    }\n    if(this.options.columns === undefined){\n      return\n    }\n    let headers = this.options.columns.map(column => column.header)\n    if(this.options.eof){\n      headers = this.stringify(headers, true) + this.options.record_delimiter\n    }else{\n      headers = this.stringify(headers)\n    }\n    this.push(headers)\n  }\n  __cast(value, context){\n    const type = typeof value\n    try{\n      if(type === 'string'){ // Fine for 99% of the cases\n        return [undefined, this.options.cast.string(value, context)]\n      }else if(type === 'bigint'){\n        return [undefined, this.options.cast.bigint(value, context)]\n      }else if(type === 'number'){\n        return [undefined, this.options.cast.number(value, context)]\n      }else if(type === 'boolean'){\n        return [undefined, this.options.cast.boolean(value, context)]\n      }else if(value instanceof Date){\n        return [undefined, this.options.cast.date(value, context)]\n      }else if(type === 'object' && value !== null){\n        return [undefined, this.options.cast.object(value, context)]\n      }else{\n        return [undefined, value, value]\n      }\n    }catch(err){\n      return [err]\n    }\n  }\n  normalize_columns(columns){\n    if(columns === undefined || columns === null){\n      return undefined\n    }\n    if(typeof columns !== 'object'){\n      throw Error('Invalid option \"columns\": expect an array or an object')\n    }\n    if(!Array.isArray(columns)){\n      const newcolumns = []\n      for(let k in columns){\n        newcolumns.push({\n          key: k,\n          header: columns[k]\n        })\n      }\n      columns = newcolumns\n    }else{\n      const newcolumns = []\n      for(let column of columns){\n        if(typeof column === 'string'){\n          newcolumns.push({\n            key: column,\n            header: column\n          })\n        }else if(typeof column === 'object' && column !== undefined && !Array.isArray(column)){\n          if(!column.key){\n            throw Error('Invalid column definition: property \"key\" is required')\n          }\n          if(column.header === undefined){\n            column.header = column.key\n          }\n          newcolumns.push(column)\n        }else{\n          throw Error('Invalid column definition: expect a string or an object')\n        }\n      }\n      columns = newcolumns\n    }\n    return columns\n  }\n}\n\nconst stringify = function(){\n  let data, options, callback\n  for(let i in arguments){\n    const argument = arguments[i]\n    const type = typeof argument\n    if(data === undefined && (Array.isArray(argument))){\n      data = argument\n    }else if(options === undefined && isObject(argument)){\n      options = argument\n    }else if(callback === undefined && type === 'function'){\n      callback = argument\n    }else{\n      throw new CsvError('CSV_INVALID_ARGUMENT', [\n        'Invalid argument:',\n        `got ${JSON.stringify(argument)} at index ${i}`\n      ])\n    }\n  }\n  const stringifier = new Stringifier(options)\n  if(callback){\n    const chunks = []\n    stringifier.on('readable', function(){\n      let chunk\n      while((chunk = this.read()) !== null){\n        chunks.push(chunk)\n      }\n    })\n    stringifier.on('error', function(err){\n      callback(err)\n    })\n    stringifier.on('end', function(){\n      callback(undefined, chunks.join(''))\n    })\n  }\n  if(data !== undefined){\n    // Give a chance for events to be registered later\n    if(typeof setImmediate === 'function'){\n      setImmediate(function(){\n        for(let record of data){\n          stringifier.write(record)\n        }\n        stringifier.end()\n      })\n    }else{\n      for(let record of data){\n        stringifier.write(record)\n      }\n      stringifier.end()\n    }\n  }\n  return stringifier\n}\n\nclass CsvError extends Error {\n  constructor(code, message, ...contexts) {\n    if(Array.isArray(message)) message = message.join(' ')\n    super(message)\n    if(Error.captureStackTrace !== undefined){\n      Error.captureStackTrace(this, CsvError)\n    }\n    this.code = code\n    for(const context of contexts){\n      for(const key in context){\n        const value = context[key]\n        this[key] = Buffer.isBuffer(value) ? value.toString() : value == null ? value : JSON.parse(JSON.stringify(value))\n      }\n    }\n  }\n}\n\nstringify.Stringifier = Stringifier\n\nstringify.CsvError = CsvError\n\nmodule.exports = stringify\n\nconst isObject = function(obj){\n  return typeof obj === 'object' && obj !== null && ! Array.isArray(obj)\n}\n\nconst underscore = function(str){\n  return str.replace(/([A-Z])/g, function(_, match){\n    return '_' + match.toLowerCase()\n  })\n}\n\n// Lodash implementation of `get`\n\nconst charCodeOfDot = '.'.charCodeAt(0)\nconst reEscapeChar = /\\\\(\\\\)?/g\nconst rePropName = RegExp(\n  // Match anything that isn't a dot or bracket.\n  '[^.[\\\\]]+' + '|' +\n  // Or match property names within brackets.\n  '\\\\[(?:' +\n    // Match a non-string expression.\n    '([^\"\\'][^[]*)' + '|' +\n    // Or match strings (supports escaping characters).\n    '([\"\\'])((?:(?!\\\\2)[^\\\\\\\\]|\\\\\\\\.)*?)\\\\2' +\n  ')\\\\]'+ '|' +\n  // Or match \"\" as the space between consecutive dots or empty brackets.\n  '(?=(?:\\\\.|\\\\[\\\\])(?:\\\\.|\\\\[\\\\]|$))'\n, 'g')\nconst reIsDeepProp = /\\.|\\[(?:[^[\\]]*|([\"'])(?:(?!\\1)[^\\\\]|\\\\.)*?\\1)\\]/\nconst reIsPlainProp = /^\\w*$/\nconst getTag = function(value){\n  if(!value)\n    value === undefined ? '[object Undefined]' : '[object Null]'\n  return Object.prototype.toString.call(value)\n}\nconst isKey = function(value, object){\n  if(Array.isArray(value)){\n    return false\n  }\n  const type = typeof value\n  if(type === 'number' || type === 'symbol' || type === 'boolean' || !value || isSymbol(value)){\n    return true\n  }\n  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||\n    (object != null && value in Object(object))\n}\nconst isSymbol = function(value){\n  const type = typeof value\n  return type === 'symbol' || (type === 'object' && value && getTag(value) === '[object Symbol]')\n}\nconst stringToPath = function(string){\n  const result = []\n  if(string.charCodeAt(0) === charCodeOfDot){\n    result.push('')\n  }\n  string.replace(rePropName, function(match, expression, quote, subString){\n    let key = match\n    if(quote){\n      key = subString.replace(reEscapeChar, '$1')\n    }else if(expression){\n      key = expression.trim()\n    }\n    result.push(key)\n  })\n  return result\n}\nconst castPath = function(value, object){\n  if(Array.isArray(value)){\n    return value\n  } else {\n    return isKey(value, object) ? [value] : stringToPath(value)\n  }\n}\nconst toKey = function(value){\n  if(typeof value === 'string' || isSymbol(value))\n    return value\n  const result = `${value}`\n  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result\n}\nconst get = function(object, path){\n  path = castPath(path, object)\n  let index = 0\n  const length = path.length\n  while(object != null && index < length){\n    object = object[toKey(path[index++])]\n  }\n  return (index && index === length) ? object : undefined\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}